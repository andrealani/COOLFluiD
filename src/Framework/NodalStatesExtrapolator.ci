#include <fstream>

#include "Framework/MeshData.hh"
#include "Framework/MapGeoToTrsAndIdx.hh"
#include "Framework/State.hh"
#include "Framework/PhysicalModel.hh"
#include "Framework/GeometricEntityPool.hh"
#include "Framework/FaceTrsGeoBuilder.hh"
#include "Framework/TrsNotFoundException.hh"
#include "Framework/SubSystemStatus.hh"
#include "MathTools/MathChecks.hh"
#include "Common/SwapEmpty.hh"
#include "Common/FilesystemException.hh"
#include "Environment/DirPaths.hh"

//////////////////////////////////////////////////////////////////////////////

namespace COOLFluiD {

  namespace Framework {

//////////////////////////////////////////////////////////////////////////////

template <typename DATA>
void NodalStatesExtrapolator<DATA>::defineConfigOptions(Config::OptionList& options)
{
  using namespace std;
	
  options.addConfigOption< vector<std::string> >
    ("TrsPriorityList",
     "list of the names of the TRS defining the priority");

  options.addConfigOption< vector<std::string> >
   ("TRSName","Name of the TRSs on which values must be prescribed");

  options.addConfigOption< vector<std::string> >
    ("FileNameTw", "Name of the files with the given boundary distribution");

  options.addConfigOption< vector<std::string> >
    ("FileNameTwADF", "Name of the characters used to automatically define the names of the given magnetograms");

  options.addConfigOption< vector<CFreal> >
    ("FileNameTime", "Time corresponding to each file with the given boundary distribution");
  
  options.addConfigOption<CFreal>
    ("RotationAngle", "Rotation angle (in degrees) to apply to the wall distribution coordinates");

  options.addConfigOption<std::vector<CFuint> >
    ("RotationCoordIDs", "IDs (must be 2) of the coordinates lying in the rotation plane");

  options.addConfigOption<CFuint>
    ("TemperatureID", "ID of the temperature in the wall distribution"); 
  
  options.addConfigOption<CFuint>
    ("NbClosestPoints", "Number of closest points for surface interpolation"); 
  
  options.addConfigOption<vector<CFint> >
    ("ExtractCoordXYIDs", "IDs corresponding to the x,y coordinate (z=0) for which plane is extracted");

  options.addConfigOption<CFuint, Config::DynamicOption<> >
    ("NbIterAdiabatic", "Number of iterations to run adiabatic");
}

//////////////////////////////////////////////////////////////////////////////

template <typename DATA>
NodalStatesExtrapolator<DATA>::NodalStatesExtrapolator(const std::string& name) :
  Framework::MethodStrategy<DATA>(name),
  socket_nodes("nodes"),
  socket_nstates("nstates"),
  socket_trsID("trsID"),
  socket_states("states"),
  socket_gstates("gstates"),
  _currNodeID(0),
  _nodalValuesIDFlags(),
  _mapTrs2NodalValues(),
  _mapNodeID2TrsNodeID(),
  _mapTrsNameToID(),
  m_trsID2LookupState(),
  _orderedTrsList(),
  _neighborStates(),
  m_allSurfaces(),
  m_extractCoordZID(-1)
{
  this->addConfigOptionsTo(this);

  using namespace std;	
  
  _trsPriorityList = vector<std::string>();
  this->setParameter("TrsPriorityList",&_trsPriorityList);

  _trsName = vector<std::string>();
  this->setParameter("TRSName",&_trsName);

  m_fileNameTw = vector<std::string>();
  this->setParameter("FileNameTw",&m_fileNameTw);

  m_fileNameTwADF = vector<std::string>();
  this->setParameter("FileNameTwADF",&m_fileNameTwADF);

  m_fileNameTime = vector<CFreal>();
  this->setParameter("FileNameTime",&m_fileNameTime);
  
  m_angle = 0.0;
  this->setParameter("RotationAngle",&m_angle);

  m_xvec = std::vector<CFuint>();
  this->setParameter("RotationCoordIDs",&m_xvec);

  m_tempID = 0;
  this->setParameter("TemperatureID",&m_tempID);
  
  m_nbClosestPoints = 0;
  this->setParameter("NbClosestPoints",&m_nbClosestPoints);
  
  m_extractCoordXYID = vector<CFint>();
  this->setParameter("ExtractCoordXYIDs",&m_extractCoordXYID);

  m_nbIterAdiabatic = 0;
  this->setParameter("NbIterAdiabatic",&m_nbIterAdiabatic);
}

//////////////////////////////////////////////////////////////////////////////

template <typename DATA>
NodalStatesExtrapolator<DATA>::~NodalStatesExtrapolator()
{
  CFLog(VERBOSE, "NodalStatesExtrapolator<DATA>::~NodalStatesExtrapolator()\n");
}

//////////////////////////////////////////////////////////////////////////////

template <typename DATA>
void NodalStatesExtrapolator<DATA>::setup()
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::MathTools;
  using namespace COOLFluiD::Common;
  
  CFAUTOTRACE;
  
  Framework::MethodStrategy<DATA>::setup();
  
  const CFuint dim = PhysicalModelStack::getActive()->getDim();
  if (m_nbClosestPoints == 0) {
    m_nbClosestPoints = dim + (dim - 2); // 2 in 2D, 4 in 3D
  }
  
  if (_nodalValuesIDFlags.size() == 0) {
    _nodalValuesIDFlags.resize(PhysicalModelStack::getActive()->getNbEq());
    _nodalValuesIDFlags.assign(_nodalValuesIDFlags.size(), false);
  }

  DataHandle < Framework::Node*, Framework::GLOBAL > nodes = socket_nodes.getDataHandle();

  DataHandle<CFint> trsID = socket_trsID.getDataHandle();

  DataHandle < Framework::State*, Framework::GLOBAL > states = socket_states.getDataHandle();

  Common::SafePtr<TopologicalRegionSet> cells =
    MeshDataStack::getActive()->getTrs("InnerCells");

  SafePtr<MapGeoToTrsAndIdx> mapGeoToTrs =
    MeshDataStack::getActive()->getMapGeoToTrs("MapFacesToTrs");

  const CFuint nbCells = cells->getLocalNbGeoEnts();
  const CFuint nbNodes = nodes.size();
  _neighborStates.resize(nbNodes);

  // map between the face ID and the TRS ID (on purpose,
  // this last be one can be negative!!)
  CFMap<CFuint, CFint> mapFaceTrsID;

  // create a mapping to tell what boundary faces reference a
  // certain node
  vector< vector<CFuint> > bFacesPerNode(nbNodes);

  // loop over TRSs and consider also the ghost state neighbors
  // for the mesh nodes
  addBoundaryNeighbors(bFacesPerNode, mapFaceTrsID);

  vector<CFuint> faceNodeIDs;

  // build the list of neighbor states for each node
  for (CFuint iCell = 0; iCell < nbCells; ++iCell) {
    State *const currState = states[iCell];
    const CFuint nbNodesInCell = cells->getNbNodesInGeo(iCell);

    // if this cell shares a node with a boundary face take it into
    // account only if it shares at least a second one with the face
    for (CFuint iNode = 0; iNode < nbNodesInCell; ++iNode) {
      const CFuint nodeID = cells->getNodeID(iCell, iNode);
      cf_assert(nodeID < bFacesPerNode.size());
      const CFuint nbBFacesPerNode = bFacesPerNode[nodeID].size();
      
      // this will have to be changed in 3D
      if (nbBFacesPerNode > 0) {
        for (CFuint i = 0; i < nbBFacesPerNode; ++i) {
          // nodeID already matches
          CFuint countNodes = 1;
          // identify the i-th boundary face referencing the current node
          const CFuint faceID = bFacesPerNode[nodeID][i];
          SafePtr<TopologicalRegionSet> faceTrs = mapGeoToTrs->getTrs(faceID);
	  cf_assert(faceTrs.isNotNull());
	  const CFuint faceIdx = mapGeoToTrs->getIdxInTrs(faceID);
          cf_assert(mapGeoToTrs->isBGeo(faceID));
	  
          // number of nodes in the current face
          const CFuint nbFaceNodes = faceTrs->getNbNodesInGeo(faceIdx);
	  // Mark 2024.01.17 by HP
	  // cf_assert(nbFaceNodes >= 2 && dim >= DIM_2D || nbFaceNodes==1 && dim==DIM_1D);
	  cf_assert((nbFaceNodes >= 2 && dim >= DIM_2D) || (nbFaceNodes==1 && dim==DIM_1D));
          faceNodeIDs.resize(nbFaceNodes);
          // build a list of all the local nodeIDs in the current face
          for (CFuint jn = 0; jn < nbFaceNodes; ++jn) {
            faceNodeIDs[jn] = faceTrs->getNodeID(faceIdx, jn);
          }
	  
          // check if the current face shares more than 1 node with the
          // current cell
          for (CFuint jNode = 0; jNode < nbNodesInCell; ++jNode) {
            // the iNode-th node already matches
            if (jNode != iNode) {
              const CFuint nodeIDToMatch = cells->getNodeID(iCell, jNode);
              for (CFuint k = 0; k < nbFaceNodes; ++k) {
                if (nodeIDToMatch == faceNodeIDs[k]) {
                  countNodes++;
                }
              }
            }
          }

          // this should work also in 3D but you better check ...
          if (countNodes >= dim) {
            if (mapFaceTrsID.find(faceID) == trsID[nodeID]) {
              _neighborStates[nodeID].push_back(currState);
            }
            break;
          }
        }
      }
      else {
        // in this case the node is not contained in a bface so
        // the current state is surely a neighbor
        _neighborStates[nodeID].push_back(currState);
      }
    }
  }

  if (m_fileNameTw.size() > 0) {
    
    if (m_extractCoordXYID.size() > 0) {
      if ((m_extractCoordXYID[0] == 0 && m_extractCoordXYID[1] == 1) ||
	  (m_extractCoordXYID[0] == 1 && m_extractCoordXYID[1] == 0)) {
	m_extractCoordZID = 2;
      }
      
      if ((m_extractCoordXYID[0] == 0 && m_extractCoordXYID[1] == 2) ||
	  (m_extractCoordXYID[0] == 2 && m_extractCoordXYID[1] == 0)) {
	m_extractCoordZID = 1;
      } 
      
      if ((m_extractCoordXYID[0] == 1 && m_extractCoordXYID[1] == 2) ||
	  (m_extractCoordXYID[0] == 2 && m_extractCoordXYID[1] == 1)) {
	m_extractCoordZID = 0;
      }
    }
    
    if (std::abs(m_angle) > 0.0) {
      // conversion to radiants
      m_angle *= MathTools::MathConsts::CFrealPi()/180.;
      cf_always_assert(m_xvec.size() == 2);
    }

    allocateMappingData();

 //>> mark 2024.04.27   
    if (m_fileNameTw.size() == 1) {m_fileNameTime.resize(1, 0.0);}
    cf_assert(m_fileNameTw.size() == m_fileNameTime.size());
	CFLog(INFO, "m_fileNameTw.size():setup="<<m_fileNameTw.size()<<"\n");
	CFLog(INFO, "m_fileNameTime.size():setup="<<m_fileNameTime.size()<<"\n");
	for(CFuint i=0; i<m_fileNameTw.size(); ++i){
	    CFLog(INFO, "m_fileNameTw[i]:setup="<<m_fileNameTw[i]<<"i="<<i<<"\n");
	    CFLog(INFO, "m_fileNameTime[i]:setup="<<m_fileNameTime[i]<<"i="<<i<<"\n");
	}

 if(m_fileNameTwADF.size()>3){
  //case-dependent_1
  std::string FileName_prefix=m_fileNameTwADF[0];
  std::string FileName_suffix=m_fileNameTwADF[1];

  //case-dependent_2
  // num_of_magnetograms+1 n(t_{-1} ... t_{n+1})+1
  CFuint m_magfiles=std::stoi(m_fileNameTwADF[2]);
  CFuint Cadence=std::stoi(m_fileNameTwADF[3]);

  //case-dependent_3 
  CFuint year=std::stoi(m_fileNameTwADF[4]);
  CFuint days_Feb=28;
  if(year%4==0){
	  if(year%100==0){
		 if(year%400==0){
			days_Feb=29;
	     }
	  }
      else{
	     days_Feb=29;
	  }
  } 
  CFuint day_M=30;
  CFuint hour=0;
  CFuint hours=0;
  CFuint day=0;
  CFuint days=0;
  CFuint month=0;
  CFuint months=0;
  //case-dependent_4
  //data_start: t_0
  //CFuint data_start=40905; //10802; //32119; //32100; //62911; //
  CFuint data_start=std::stoi(m_fileNameTwADF[5]);
  CFuint zerosToAdd=0;
  CFuint current_data=data_start;
  std::string current_dataStr = std::to_string(current_data);
  CFuint desiredLength = 6;
  if(current_dataStr.size()<desiredLength){
      zerosToAdd=desiredLength-current_dataStr.size();
	  current_dataStr.insert(0,zerosToAdd,'0');
  }
  std::string current_Filename=FileName_prefix+current_dataStr+FileName_suffix;
  m_fileNameTw.resize(m_magfiles, current_Filename);
  m_fileNameTw[0]=current_Filename;
  //case-dependent_5
  //data_start-1: t_{-1}
  //current_data=40904;  //10720; //32118; //32023; //62910; //
  current_data=std::stoi(m_fileNameTwADF[6]);
  current_dataStr = std::to_string(current_data);
	if(current_dataStr.size()<desiredLength){
       zerosToAdd=desiredLength-current_dataStr.size();
	   current_dataStr.insert(0,zerosToAdd,'0');
    }
    current_Filename=FileName_prefix+current_dataStr+FileName_suffix;
    m_fileNameTw[1]=current_Filename;
    m_fileNameTw[2]=m_fileNameTw[0];
	for (int i = 0; i < 3; ++i){
	   CFLog(INFO, "m_fileNameTw[i]:setup="<<m_fileNameTw[i]<<" i="<<i<<"\n");
	}
  current_data=data_start;
  for (int i = 3; i < m_magfiles; ++i){
	hour=current_data%100+Cadence;
	day=(current_data/100)%100;
	month=current_data/10000;
	hours=hour%24;
	day+=hour/24;
	if(month==1 || month==3 || month ==5 || month==7 || month==8 || month ==10 || month==12){
	   day_M=31;
	}
	else if(month==2){
	   day_M=days_Feb;
	}
	else{
	   day_M=30;
	}
	days=day%day_M;
	month+=day/day_M;
	if(days==0){
	   days=day_M;
	   month-=1;
	}
	if(month>12){
	   year+=month/12;
	   days_Feb=28;
	   if(year%4==0){
	      if(year%100==0){
		     if(year%400==0){
			    days_Feb=29;
			 }
		  }
		  else{
		     days_Feb=29;
		  }
	   }
	}
	months=month%12;
	if(months==0){
	   months=12;
	}
	current_data=months*10000+days*100+hours;
	current_dataStr = std::to_string(current_data);
	if(current_dataStr.size()<desiredLength){
       zerosToAdd=desiredLength-current_dataStr.size();
	   current_dataStr.insert(0,zerosToAdd,'0');
    }
    current_Filename=FileName_prefix+current_dataStr+FileName_suffix;
    m_fileNameTw[i]=current_Filename;
	CFLog(INFO, "m_fileNameTw[i]:setup="<<m_fileNameTw[i]<<" i="<<i<<"\n");
  }
  CFLog(INFO, "m_fileNameTwADF.size():setup="<<m_fileNameTwADF.size()<<"\n");
  
  CFreal current_time=0.0;
  m_fileNameTime.resize(m_magfiles, current_time);
  m_fileNameTime[0]=current_time;
  CFLog(INFO, "m_fileNameTime[0]:setup="<<m_fileNameTime[0]<<"\n");
  for (int i = 1; i < m_magfiles; ++i){
     current_time=(i-2)*2.4876*(double)Cadence;   
	 //for cadence=6, choose "current_time=(i-2)*14.9254;"
	 m_fileNameTime[i]=current_time;
	 CFLog(INFO, "m_fileNameTime[i]:setup="<<m_fileNameTime[i]<<" i="<<i<<"\n");
  }
  CFLog(INFO, "m_fileNameTime.size():setup="<<m_fileNameTime.size()<<"\n");
 }
 //>> mark 2024.04.27

    if (m_fileNameTw.size() > 1) {
      // read and store all the surface objects, one for each boundary file
      // these will be used later on for time interpolation
      m_allSurfaces.resize(m_fileNameTw.size());
      for (CFuint is = 0; is < m_fileNameTw.size(); ++is) {
	readSurfaceData(m_allSurfaces[is], m_fileNameTw[is]);
	const CFuint nbSurf = m_allSurfaces[is].size();
	cf_assert(nbSurf >= 1);
	CFLog(INFO, "m_allSurfaces[is].size()="<<m_allSurfaces[is].size()<<", is="<<is<<", dim="<<dim<<"\n");
	CFLog(INFO, "m_allSurfaces[is][0]->Tw[100]="<<m_allSurfaces[is][0]->Tw[100]<<", m_allSurfaces[is][0]->xyz(100,2)="<<m_allSurfaces[is][0]->xyz(100,2)<< 
	   ", m_allSurfaces[is][0]->xyz(100,1)="<<m_allSurfaces[is][0]->xyz(100,1)<<", m_allSurfaces[is][0]->xyz(100,0)="<<m_allSurfaces[is][0]->xyz(100,0)<< "\n");
	CFLog(INFO, "m_allSurfaces[is][0]->Tw[200]="<<m_allSurfaces[is][0]->Tw[200]<<", m_allSurfaces[is][0]->xyz(200,2)="<<m_allSurfaces[is][0]->xyz(200,2)<<
	   ", m_allSurfaces[is][0]->xyz(200,1)="<<m_allSurfaces[is][0]->xyz(200,1)<<", m_allSurfaces[is][0]->xyz(200,0)="<<m_allSurfaces[is][0]->xyz(200,0)<< "\n");
      }
    }
    
    // store SurfaceData for time "0"
    readSurfaceData(m_surfaceAtTime, m_fileNameTw[0]);
	//CFLog(INFO, "m_surfaceAtTime.size()="<<m_surfaceAtTime.size()<<"\n");
    
    // at first just extrapolate for the first boundary file
	//SurfaceData* m_surfaceAtTime = new SurfaceData(); 
	//m_surfaceAtTime.resize(1);
	//m_surfaceAtTime = m_allSurfaces[0];
	//m_surfaceAtTime=m_allSurfaces[2];
    extrapolateVarsFromFile(m_surfaceAtTime);
	//extrapolateVarsFromFile(m_allSurfaces[0]);
  }
}

//////////////////////////////////////////////////////////////////////////////

template <typename DATA>
void NodalStatesExtrapolator<DATA>::addBoundaryNeighbors
(std::vector< std::vector<CFuint> >& bFacesPerNode,
 Common::CFMap<CFuint, CFint>& mapFaceTrsID)
{
  CFAUTOTRACE;
  
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::MathTools;
  using namespace COOLFluiD::Common;

  DataHandle<CFint> trsID = socket_trsID.getDataHandle();

  // reset all the trsIDs to -1
  trsID = -1;

  vector< SafePtr<TopologicalRegionSet> > trsList = MeshDataStack::getActive()->getTrsList();

  if (_trsPriorityList.size() > 0) {
    for (CFuint i = 0; i < _trsPriorityList.size(); ++i) {
      const std::string name = _trsPriorityList[i];
      bool nameFound = false;
      for (CFuint j = 0; j < trsList.size(); ++j) {
	if (name == trsList[j]->getName()) {
	  _orderedTrsList.push_back(trsList[j]);
	  nameFound = true;
	  break;
	}
      }
      if (!nameFound) {
	throw TrsNotFoundException (FromHere(), name + " not found!!");
      }
    }
  }
  else {
    for (CFuint iTRS = 0; iTRS < trsList.size(); ++iTRS) {
        SafePtr<TopologicalRegionSet> currTrs = trsList[iTRS];

      if (currTrs->getName() != "InnerCells" &&
         currTrs->getName() != "InnerFaces" &&
         currTrs->getName() != "PartitionFaces") {

         _orderedTrsList.push_back(trsList[iTRS]);
      }
    }
  }

  GeometricEntityPool<FaceTrsGeoBuilder> geoBuilder;
  SafePtr<FaceTrsGeoBuilder> geoBuilderPtr = geoBuilder.getGeoBuilder();
  geoBuilderPtr->setDataSockets(socket_states, socket_gstates, socket_nodes);

  geoBuilder.setup();

  FaceTrsGeoBuilder::GeoData& geoData = geoBuilder.getDataGE();

  const CFint nbTRSs = _orderedTrsList.size();
  for (CFint iTRS = 0; iTRS < nbTRSs; ++iTRS) {
    SafePtr<TopologicalRegionSet> currTrs = _orderedTrsList[iTRS];

    if (currTrs->getName() != "InnerCells" &&
        currTrs->getName() != "InnerFaces" &&
        currTrs->getName() != "PartitionFaces") {

      CFuint countTrs = 0;
      geoData.trs = currTrs;
      geoData.isBFace = true;

      const CFuint nbTrsFaces = currTrs->getLocalNbGeoEnts();
      for (CFuint iFace = 0; iFace < nbTrsFaces; ++iFace) {
        CFLogDebugMed( "iFace = " << iFace << "\n");

        // build the GeometricEntity
        geoData.idx = iFace;
        GeometricEntity *const currFace = geoBuilder.buildGE();

        State* const gstate = currFace->getState(1);
        cf_assert(gstate != CFNULL);

        const vector<Node*>* const bnodes = currFace->getNodes();
        const CFuint nbNodesInFace = bnodes->size();
        for (CFuint iNode = 0; iNode < nbNodesInFace; ++iNode) {
          const CFuint nodeID = (*bnodes)[iNode]->getLocalID();
          // set this face in the list of boundary faces referencing
          // this node
          bFacesPerNode[nodeID].push_back(currFace->getID());

          // if the trsID is different from -1 or the current one
          // nothing will happen : this is to prevent to distribute
          // contributions to CORNER boundary nodes from different TRSs
          if (trsID[nodeID] == -1) {
            // if the trsID hasn't been set yet, it is done and
            // the corresponding nodal state and sum of the weights are
            // reset to 0.
            trsID[nodeID] = iTRS;

            if (countTrs == 0) {
	      // register the name of the TRS with the corresponding ID
	      _mapTrsNameToID.insert(currTrs->getName(), iTRS);
              countTrs++;
            }
          }

          if (trsID[nodeID] == iTRS) {
            // this neighbor must be considered
            _neighborStates[nodeID].push_back(gstate);
          }

          mapFaceTrsID.insert(currFace->getID(), iTRS);
        }

        geoBuilder.releaseGE();
      }
    }
  }

  mapFaceTrsID.sortKeys();
  _mapTrsNameToID.sortKeys();
}

//////////////////////////////////////////////////////////////////////////////

template <typename DATA>
void NodalStatesExtrapolator<DATA>::allocateMappingData()
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::MathTools;
  using namespace COOLFluiD::Common;
  
  CFLog(VERBOSE, "NodalStatesExtrapolator<DATA>::allocateMappingData() => START\n");
    
  // Get the TRS list
  vector< SafePtr<TopologicalRegionSet> > trsList;
  for (CFuint i = 0; i < _trsName.size(); ++i) {
    trsList.push_back(MeshDataStack::getActive()->getTrs(_trsName[i]));
  }  
  
  // build the mapTrs2NodalValues storage
  SafePtr<vector<MapTrs2NodalValues*> > mapTrs2NodalValues = getMapTrs2NodalValues();

  // ideally this should be handled by NodalStatesExtrapolator but unfortunately its setup()
  // is called after this function ... AL: ?? recheck this comment
  mapTrs2NodalValues->resize(PhysicalModelStack::getActive()->getNbEq());
  // resize the mapping TRS to nodal values with the number of equations
  // you have one map for each variable
 
  for (CFuint i = 0; i < mapTrs2NodalValues->size(); ++i) {
    (*mapTrs2NodalValues)[i] = new MapTrs2NodalValues(); 
  }
 
  // allocate storage for mapping TRS to nodal values (temperature in this case)
  // AL: bug during cleanup if this is used
  // (*mapTrs2NodalValues)[m_tempID] = new MapTrs2NodalValues();
  
  for (CFuint iTrs = 0; iTrs < trsList.size(); ++iTrs) {
    SafePtr<TopologicalRegionSet> trs = trsList[iTrs];
    const CFuint nbTrsNodes = trs->getNbNodesInTrs();
    RealVector* tWall = new RealVector(0.0,nbTrsNodes);
    (*mapTrs2NodalValues)[m_tempID]->insert(&*trs, tWall);
  }
  (*mapTrs2NodalValues)[m_tempID]->sortKeys();
  
  // allocate storage for mapping TRS to a mapping local (in the local mesh) nodeIDs
  // and local TRS nodeIDs
  SafePtr<MapTrsNodeIDs> mapNodeID2TrsNodeID = getMapTrs2NodeIDs();

  for (CFuint iTrs = 0; iTrs < trsList.size(); ++iTrs) {
    SafePtr<TopologicalRegionSet> trs = trsList[iTrs];
    SafePtr<vector<CFuint> > trsNodeIDs = trs->getNodesInTrs();
    const CFuint nbTrsNodes = trsNodeIDs->size();
    CFMap<CFuint,CFuint>* mapNodeIDs = new CFMap<CFuint,CFuint>(nbTrsNodes);
    for (CFuint i = 0; i < nbTrsNodes; ++i) {
      mapNodeIDs->insert((*trsNodeIDs)[i],i);
    }
    mapNodeIDs->sortKeys();
    mapNodeID2TrsNodeID->insert(&*trs, mapNodeIDs);
  }
  mapNodeID2TrsNodeID->sortKeys();

  // array of flags telling which interpolated or previously computed nodal values are available
  _nodalValuesIDFlags.resize(PhysicalModelStack::getActive()->getNbEq());
  cf_assert(_nodalValuesIDFlags.size() > 0);
  _nodalValuesIDFlags.assign(_nodalValuesIDFlags.size(), false);
  _nodalValuesIDFlags[m_tempID] = true;

  CFLog(VERBOSE, "NodalStatesExtrapolator<DATA>::allocateMappingData() => END\n");
}

//////////////////////////////////////////////////////////////////////////////

template <typename DATA>
void NodalStatesExtrapolator<DATA>::extrapolateVarsFromFileInTime()
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::MathTools;
  using namespace COOLFluiD::Common;
  // mark 2023.12.21 by HP
  const CFuint dim = (m_extractCoordZID < 0) ? PhysicalModelStack::getActive()->getDim() : 3;
  CFLog(INFO, "NodalStatesExtrapolator<DATA>::extrapolateVarsFromFileInTime() => START"<<", dim="<<dim<<"\n");
  
  const CFreal currTimeDim = SubSystemStatusStack::getActive()->getCurrentTimeDim();
  const CFreal maxTimeDim = SubSystemStatusStack::getActive()->getMaxTimeDim();
  const CFreal maxDT = SubSystemStatusStack::getActive()->getDT();
  // time corresponding to the first input file used for the interpolation
  
  //>> mark 2024.04.27
  /*
  CFLog(INFO, "m_fileNameTime.size():extrapolateVarsFromFileInTime="<<m_fileNameTime.size()<<"\n");
  CFLog(INFO, "m_fileNameTw.size():extrapolateVarsFromFileInTime="<<m_fileNameTw.size()<<"\n");
  	for(CFuint i=0; i<m_fileNameTw.size(); ++i){
        CFLog(INFO, "m_fileNameTime[i]:extrapolateVarsFromFileInTime="<<m_fileNameTime[i]<<"i="<<i<<"\n");
        CFLog(INFO, "m_fileNameTw[i]:extrapolateVarsFromFileInTime="<<m_fileNameTw[i]<<"i="<<i<<"\n");
	}
  */
  //>> mark 2024.04.27

  const CFreal startTime = m_fileNameTime[0];
  // time corresponding to the last input file used for the interpolation
  const CFreal endTime   = m_fileNameTime.back();
  cf_assert(endTime >= maxTimeDim);
  // here you use m_allSurfaces as a basis for interpolating at current time and storing
  // the interpolated file into m_surfaceAtTime
  //
  // I remind here the definition of SurfaceData:
  //
  // class SurfaceData {
  // public:
  //  RealMatrix xyz;
  //  RealVector Tw;
  // };
  //
  // Note that xyz and Tw have been already allocated to the right size in the setup()

  //////////////////////////////////////////////////////////////////////////////
  //Mark 2023/12/20  by HP
  CFreal Time_ref2phy;
  double Coefi1;
  double Coefi2;
  double derivative1;
  double derivative2;
  double h00;
  double h10;
  double h01;
  double h11;
  double time_norm;
  CFreal Temp;
  CFreal Temp1;
  CFreal Temp2;
  CFreal deri1=0.;
  CFreal deri2=0.;
  Time_ref2phy = 1447.2/3600.0;
  CFLog(INFO, "currTimeDim="<<currTimeDim*Time_ref2phy<<", maxTimeDim="<<maxTimeDim*Time_ref2phy<<", maxDT="<<maxDT*Time_ref2phy<<
	  ", startTime="<<startTime*Time_ref2phy<<", endTime="<<endTime*Time_ref2phy<<"\n");
  for (CFuint i = 2; i < m_fileNameTime.size()-1; ++i) {
    if((currTimeDim-m_fileNameTime[i])*(m_fileNameTime[i+1]-currTimeDim)>=0.){
	  Temp=m_fileNameTime[i+1]-m_fileNameTime[i];
	  Coefi1=(m_fileNameTime[i+1]-currTimeDim)/Temp;
	  Coefi2=(currTimeDim-m_fileNameTime[i])/Temp;
	  CFLog(INFO, "Coefi1="<<Coefi1<<", Coefi2="<<Coefi2<<", m_fileNameTime[i-1]="<<m_fileNameTime[i-1]*Time_ref2phy<<", m_fileNameTime[i]="<<m_fileNameTime[i]*Time_ref2phy<<
	  ", m_fileNameTime[i+1]="<<m_fileNameTime[i+1]*Time_ref2phy<<", m_fileNameTime[i+2]="<<m_fileNameTime[i+2]*Time_ref2phy<<", i="<<i<<"\n");
	  Temp1=m_fileNameTime[i]-m_fileNameTime[i-1];
	  Temp2=m_fileNameTime[i+2]-m_fileNameTime[i+1];
	  
	  //This subroutine also works for linear interpolation
	  //readSurfaceDataextrapolator(m_surfaceAtTime, m_fileNameTw[i],m_fileNameTw[i+1],Coefi1,Coefi2);

	  //used for linear interpolation
	  const SurfaceData& sf1 = *m_allSurfaces[i][0];
	  const SurfaceData& sf2 = *m_allSurfaces[i+1][0];
	  //used for cubic hermit interpolation
	  const SurfaceData& sfm = *m_allSurfaces[i-1][0];
	  const SurfaceData& sfp = *m_allSurfaces[i+2][0];
	  time_norm=Coefi2;
	  h00=2.0*pow(time_norm,3.0)-3.0*pow(time_norm,2.0)+1.0;
	  h10=pow(time_norm,3.0)-2.0*pow(time_norm,2.0)+time_norm;
	  h01=-2.0*pow(time_norm,3.0)+3.0*pow(time_norm,2.0);
	  h11=pow(time_norm,3.0)-pow(time_norm,2.0);

      const CFuint nbPoints = sf2.Tw.size();
	  CFLog(INFO, "CFuint nbPoints="<<nbPoints<<"\n"); 
///*
      //CFLog(INFO, "test whether have been commented \n");
	  SurfaceData* sf0 = new SurfaceData();
      sf0->xyz.resize(nbPoints,dim);
      sf0->Tw.resize(nbPoints);
	  //sf0->xyz=sf1.xyz;
	  sf0->xyz=sf1.xyz;
	  for (CFuint ip = 0; ip < nbPoints; ++ip) {
	    for (CFuint iDim = 0; iDim < dim; ++iDim) {
		  sf0->xyz(ip,iDim)=sf1.xyz(ip,iDim);
		}
	  }

	  for (CFuint ip = 0; ip < nbPoints; ++ip) {
	    // Linear interpolation
	    sf0->Tw[ip]=sf1.Tw[ip] * Coefi1 + sf2.Tw[ip]* Coefi2;
		//m_surfaceAtTime[0]->Tw[ip] = sf1.Tw[ip] * Coefi1 + sf2.Tw[ip]* Coefi2;

		//Cubic Hermit temporal interpolation
		derivative1=0.5*((sf1.Tw[ip]-sfm.Tw[ip])/Temp1+(sf2.Tw[ip]-sf1.Tw[ip])/Temp);
	    derivative2=0.5*((sfp.Tw[ip]-sf2.Tw[ip])/Temp2+(sf2.Tw[ip]-sf1.Tw[ip])/Temp);
		m_surfaceAtTime[0]->Tw[ip] = sf1.Tw[ip]*h00+derivative1*Temp*h10+
		sf2.Tw[ip]*h01+derivative2*Temp*h11;
		deri1+=std::abs(derivative1);
		deri2+=std::abs(derivative2);
		//if(ip == 10 || ip==20 || ip == 30) {
		//  CFLog(INFO, "sf0->Tw[ip]="<<sf0->Tw[ip]<<", m_surfaceAtTime[0]->Tw[ip]="<< m_surfaceAtTime[0]->Tw[ip]<<", derivative1="<<derivative1<<", derivative2="<<derivative2<<", ip="<<ip<<"\n");
		//}
      } //ip
	  deri1/=nbPoints;
	  deri2/=nbPoints;	  
	  CFLog(INFO, "h01="<<h01<<", h10="<<h10<<", h01="<<h01<<", h11="<< h11<<"\n");
	  CFLog(INFO, "deri1="<<deri1<<", deri2="<<deri2<< "\n");

	 // CFLog(INFO, "sf0->xyz(10,2)="<<sf0->xyz(10,2)<<", sf0->xyz(20,2)="<<sf0->xyz(20,2)<<", sf0->xyz(30,2)="<<sf0->xyz(30,2)<<"\n");
	 // CFLog(INFO, "sf1.xyz(10,2)="<<sf1.xyz(10,2)<<", sf1.xyz(20,2)="<<sf1.xyz(20,2)<<", sf1.xyz(30,2)="<<sf1.xyz(30,2)<<"\n");
	  //CFLog(INFO, "sf0->xyz(10,1)="<<sf0->xyz(10,1)<<", sf0->xyz(20,1)="<<sf0->xyz(20,1)<<", sf0->xyz(30,1)="<<sf0->xyz(30,1)<<"\n");
	  //CFLog(INFO, "sf1.xyz(10,1)="<<sf1.xyz(10,1)<<", sf1.xyz(20,1)="<<sf1.xyz(20,1)<<", sf1.xyz(30,1)="<<sf1.xyz(30,1)<<"\n");
	 // CFLog(INFO, "sf0->xyz(10,0)="<<sf0->xyz(10,0)<<", sf0->xyz(20,0)="<<sf0->xyz(20,0)<<", sf0->xyz(30,0)="<<sf0->xyz(30,0)<<"\n");
	 // CFLog(INFO, "sf1.xyz(10,0)="<<sf1.xyz(10,0)<<", sf1.xyz(20,0)="<<sf1.xyz(20,0)<<", sf1.xyz(30,0)="<<sf1.xyz(30,0)<<"\n");
	  //CFLog(INFO, "m_surfaceAtTime[0]->xyz(10,2)="<<m_surfaceAtTime[0]->xyz(10,2)<<", m_surfaceAtTime[0]->xyz(20,2)="<< m_surfaceAtTime[0]->xyz(20,2)<<", m_surfaceAtTime[0]->xyz(30,2)="<< m_surfaceAtTime[0]->xyz(30,2)<< "\n");
	  //CFLog(INFO, "m_surfaceAtTime[0]->xyz(10,1)="<<m_surfaceAtTime[0]->xyz(10,1)<<", m_surfaceAtTime[0]->xyz(20,1)="<< m_surfaceAtTime[0]->xyz(20,1)<<", m_surfaceAtTime[0]->xyz(30,1)="<< m_surfaceAtTime[0]->xyz(30,1)<< "\n");
	  //CFLog(INFO, "m_surfaceAtTime[0]->xyz(10,0)="<<m_surfaceAtTime[0]->xyz(10,0)<<", m_surfaceAtTime[0]->xyz(20,0)="<< m_surfaceAtTime[0]->xyz(20,0)<<", m_surfaceAtTime[0]->xyz(30,0)="<< m_surfaceAtTime[0]->xyz(30,0)<< "\n");
	  //CFLog(INFO, "sf1.xyz[100,2]-sf1.xyz[200,2]="<<sf1.xyz[100]-sf1.xyz[200]<<"\n");
	  //CFLog(INFO, "sf0->Tw[10]="<<sf0->Tw[10]<<", sf0->Tw[20]="<<sf0->Tw[10]<<", sf0->Tw[30]="<<sf0->Tw[30]<< "\n");

	  //CFLog(INFO, "sf1.Tw[10]="<<sf1.Tw[10]<<", sf1.Tw[20]="<<sf1.Tw[20]<<", sf1.Tw[30]="<<sf1.Tw[30]<< "\n");
	  //CFLog(INFO, "sf2.Tw[10]="<<sf2.Tw[10]<<", sf2.Tw[20]="<<sf2.Tw[20]<<", sf2.Tw[30]="<<sf2.Tw[30]<< "\n");
	  //CFLog(INFO, "m_surfaceAtTime[0]->Tw[10]="<<m_surfaceAtTime[0]->Tw[10]<<", m_surfaceAtTime[0]->Tw[20]="<< m_surfaceAtTime[0]->Tw[20]<<", m_surfaceAtTime[0]->Tw[30]="<< m_surfaceAtTime[0]->Tw[30]<< "\n");
///*/
	  //readSurfaceDataextrapolator(m_surfaceAtTime, m_fileNameTw[i],m_fileNameTw[i+1],Coefi1,Coefi2);
	  //readSurfaceData(m_surfaceAtTime, m_fileNameTw[i]);
	} //i
  }

  //////////////////////////////////////////////////////////////////////////////
  CFLog(INFO, "Coefi1+ Coefi2="<<Coefi1+ Coefi2<<"\n");
  extrapolateVarsFromFile(m_surfaceAtTime);
  //CFLog(INFO, "m_surfaceAtTime[0]->xyz(10,2)="<<m_surfaceAtTime[0]->xyz(10,2)<<", m_surfaceAtTime[0]->xyz(20,2)="<< m_surfaceAtTime[0]->xyz(20,2)<<", m_surfaceAtTime[0]->xyz(30,2)="<< m_surfaceAtTime[0]->xyz(30,2)<< "\n");  

  CFLog(INFO, "NodalStatesExtrapolator<DATA>::extrapolateVarsFromFileInTime() => END\n");
}

//////////////////////////////////////////////////////////////////////////////

template <typename DATA>
void NodalStatesExtrapolator<DATA>::extrapolateVarsFromFile
(const std::vector<SurfaceData*>& surfaces)
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::MathTools;
  using namespace COOLFluiD::Common;
  
  CFLog(INFO, "NodalStatesExtrapolator<DATA>::extrapolateVarsFromFile() => START\n");
  
  const CFuint nbSurf = surfaces.size();
  cf_assert(nbSurf >= 1);
  
  const CFuint dim = PhysicalModelStack::getActive()->getDim();
  RealVector tmpNode(dim);
  DataHandle<Node*,GLOBAL> nodes = socket_nodes.getDataHandle();
  
  ClosestPointData closestPoint;
  closestPoint.surfaceIDs.resize(m_nbClosestPoints); 
  closestPoint.pointsIDs.resize(m_nbClosestPoints); 
  closestPoint.r.resize(m_nbClosestPoints); 

  // Get the TRS list
  vector< SafePtr<TopologicalRegionSet> > trsList;
  for (CFuint i = 0; i < _trsName.size(); ++i) {
    trsList.push_back(MeshDataStack::getActive()->getTrs(_trsName[i]));
  }

  SafePtr<vector<MapTrs2NodalValues*> > mapTrs2NodalValues = getMapTrs2NodalValues();
  
  for (CFuint iTrs = 0; iTrs < trsList.size(); ++iTrs) {
    SafePtr<TopologicalRegionSet> trs = trsList[iTrs];
    RealVector& nodalTwall = *(*mapTrs2NodalValues)[m_tempID]->find(&*trs);
    SafePtr<vector<CFuint> > trsNodeIDs = trs->getNodesInTrs();
    const CFuint nbTrsNodes = trsNodeIDs->size();
    for (CFuint iNode = 0; iNode < nbTrsNodes; ++iNode) {
      const Node& currNode = *nodes[(*trsNodeIDs)[iNode]];
      // during this preprocessing m_nbClosestPoints closest neighbors are sought
      closestPoint.reset();
      
      bool flagOut = false;
      for (CFuint is = 0; is < nbSurf && (!flagOut); ++is) {
	const SurfaceData& sf = *surfaces[is];
	const CFuint nbPoints = sf.Tw.size();
	for (CFuint ip = 0; ip < nbPoints; ++ip) {
	  sf.xyz.putRow(ip,tmpNode);
	  // CFLog(INFO, "is = " << is << ", ip = " << ip << ", node = " << tmpNode << "\n");
	  const CFreal distance = MathFunctions::getDistance(currNode, tmpNode);
	  // CFLog(INFO, "distance = " << distance << "\n");
	  if (distance < 1e-8) {
	    // in this case we assume that the current node coincides with the mapping node
	    // set the matching Twall in the array
	    cf_assert(iNode < nodalTwall.size());
	    cf_assert(ip < sf.Tw.size());
	    nodalTwall[iNode] = sf.Tw[ip]; 
	    flagOut = true;
	    break;
	  }
	  else {
	    CFint counter = -1;
	    for (CFuint n = 0; n < m_nbClosestPoints; ++n) {
	      cf_assert(n < closestPoint.r.size());
	      if (distance < closestPoint.r[n]) {
		counter++;
	      }
	    }
	    
	    if (counter >= 0) {
	      // counter == (m_nbClosestPoints-1) corresponds to the point with min distance within the stencil
	      // counter == 0                     corresponds to the point with max distance within the stencil
	      for (CFuint i = 0; i < static_cast<CFuint>(counter); ++i) {
		closestPoint.regressionFromTo(i+1, i);
	      }
	      
	      cf_assert(counter < closestPoint.surfaceIDs.size());
	      // CFLog(INFO, "IN is = " << is << ", counter = " << counter << ", ip = " << ip << ", distance   = " << distance << "\n");
	      closestPoint.surfaceIDs[counter] = is;
	      cf_assert(counter < closestPoint.pointsIDs.size());
	      closestPoint.pointsIDs[counter] = ip;
	      cf_assert(counter < closestPoint.r.size());
	      closestPoint.r[counter] = distance;
	      
	      // sanity check
	      // const CFuint nbN = m_nbClosestPoints -1;
	      // 	    for (CFuint i = 0; i < nbN; ++i) {
	      // 	      cf_always_assert (closestPoint.r[i+1] <= closestPoint.r[i]);
	      // 	    }
	    }
	  }
	}
      }

      if (!flagOut) {
	CFreal matchingTw = 0.0;
	CFreal sumWeights = 0.0;
	for (CFuint n = 0; n < m_nbClosestPoints; ++n) {
	  const CFuint idxs = closestPoint.surfaceIDs[n];
	  cf_assert(idxs < surfaces.size());
	  const SurfaceData& sf = *surfaces[idxs];
	  cf_assert(closestPoint.r[n] > 0.);
	  const CFreal weight = 1./closestPoint.r[n]; 
	  sumWeights += weight;
	  const CFuint idxp = closestPoint.pointsIDs[n];
	  cf_assert(idxp < sf.Tw.size());
	  matchingTw += weight*sf.Tw[idxp]; 
	}
	matchingTw /= sumWeights;
	
	// set the matching Twall in the array
	nodalTwall[iNode] = matchingTw;
	// cf_assert(matchingTw > 0.0);
      }
    }
  }
  
  CFLog(INFO, "NodalStatesExtrapolator<DATA>::extrapolateVarsFromFile() => END\n");
}

//////////////////////////////////////////////////////////////////////////////

template <typename DATA>
void NodalStatesExtrapolator<DATA>::readSurfaceData
(std::vector<SurfaceData*>& surfaces, const std::string& fileName)
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::MathTools;
  using namespace COOLFluiD::Common;
  
  const CFuint dim = (m_extractCoordZID < 0) ? PhysicalModelStack::getActive()->getDim() : 3;

  boost::filesystem::path fname;
  if (Common::StringOps::startsWith(fileName,"."))
  {
    fname = boost::filesystem::path(fileName);
  }
  else
  {
    fname = Environment::DirPaths::getInstance().getBaseDir() / boost::filesystem::path(fileName);
  }

  // check the file type
  std::ifstream fin(fname.string().c_str());
  if(!fin) throw Common::FilesystemException (FromHere(),"Could not open file: " + fname.string());
  // The format is as follows:
  
  // NumberOfSurfaces
  // SURFACE_NAME1 NumberOfPoints
  // x y z T
  // ...
  // SURFACE_NAME2 NumberOfPoints
  // x y z T
  // ...
  
  CFLogInfo("NodalStatesExtrapolator::readSurfaceData() => START reading file " <<
	    fileName << "\n");
  
  CFuint nbSurf = 0;
  fin >> nbSurf;
  surfaces.resize(nbSurf);
  
  // store all the surface data
  for (CFuint is = 0; is < nbSurf; ++is) {
    std::string nameSurf = "";
    fin >> nameSurf;
    CFuint nbPoints = 0;
    fin >> nbPoints;
    
    CFLogInfo("nbSurf = " << is << "/" << nbSurf << ", NameSurf = " <<
	      nameSurf << ", nbPoints = " << nbPoints << "\n");
    SurfaceData* sf = new SurfaceData(); 
    sf->xyz.resize(nbPoints,dim);
    sf->Tw.resize(nbPoints);
    
    for (CFuint ip = 0; ip < nbPoints; ++ip) {
      for (CFuint iDim = 0; iDim < dim; ++iDim) {
	fin >> sf->xyz(ip,iDim);
      }
      
      if (m_xvec.size() > 0) {
	cf_assert(std::abs(m_angle) > 0.0);
	
	// rotate coordinates
	const CFreal x1 =  sf->xyz(ip,m_xvec[0])*std::cos(m_angle) + sf->xyz(ip,m_xvec[1])*std::sin(m_angle);
	const CFreal y1 = -sf->xyz(ip,m_xvec[0])*std::sin(m_angle) + sf->xyz(ip,m_xvec[1])*std::cos(m_angle);
	sf->xyz(ip,m_xvec[0]) = x1;				   
	sf->xyz(ip,m_xvec[1]) = y1;				   
      }	
      fin >> sf->Tw[ip];
    }
	
	//Wait for further checking
    surfaces[is] = (m_extractCoordZID < 0) ?  sf : extractLineData(sf);  
  }
  
  CFLogInfo("NodalStatesExtrapolator::readSurfaceData() => END reading file " <<
	    fileName << "\n"); 
}

//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////

template <typename DATA>
void NodalStatesExtrapolator<DATA>::readSurfaceDataextrapolator
(std::vector<SurfaceData*>& surfaces, const std::string& fileName, const std::string& fileName2, double Coefi1, double Coefi2)
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::MathTools;
  using namespace COOLFluiD::Common;
  
  const CFuint dim = (m_extractCoordZID < 0) ? PhysicalModelStack::getActive()->getDim() : 3;

  boost::filesystem::path fname;
  //read the first file
  if (Common::StringOps::startsWith(fileName,"."))
  {
    fname = boost::filesystem::path(fileName);
  }
  else
  {
    fname = Environment::DirPaths::getInstance().getBaseDir() / boost::filesystem::path(fileName);
  }
  // check the file type
  std::ifstream fin(fname.string().c_str());
  if(!fin) throw Common::FilesystemException (FromHere(),"Could not open file: " + fname.string());

  //read the second file
    if (Common::StringOps::startsWith(fileName2,"."))
  {
    fname = boost::filesystem::path(fileName2);
  }
  else
  {
    fname = Environment::DirPaths::getInstance().getBaseDir() / boost::filesystem::path(fileName2);
  }
  std::ifstream fin2(fname.string().c_str());
  if(!fin2) throw Common::FilesystemException (FromHere(),"Could not open file: " + fname.string());

  // The format is as follows:
  
  // NumberOfSurfaces
  // SURFACE_NAME1 NumberOfPoints
  // x y z T
  // ...
  // SURFACE_NAME2 NumberOfPoints
  // x y z T
  // ...
  
  CFLogInfo("NodalStatesExtrapolator::readSurfaceDataextrapolator() => START reading 1st file " <<
	    fileName << ", dim="<< dim << "\n");
  
  CFuint nbSurf = 0;
  CFuint nbPoints = 0;
  std::string nameSurf = "";

  fin >> nbSurf;
  surfaces.resize(nbSurf);
  
  // store all the surface data
  SurfaceData* sf = new SurfaceData(); 
  SurfaceData* sf2 = new SurfaceData(); 

  for (CFuint is = 0; is < nbSurf; ++is) {
    //std::string nameSurf = "";
    fin >> nameSurf;
    fin >> nbPoints;
    
    CFLogInfo("nbSurf1 = " << is << "/" << nbSurf << ", NameSurf = " <<
	      nameSurf << ", nbPoints = " << nbPoints << ", dim="<< dim << "\n");
   
    sf->xyz.resize(nbPoints,dim);
    sf->Tw.resize(nbPoints);
    
    for (CFuint ip = 0; ip < nbPoints; ++ip) {
      for (CFuint iDim = 0; iDim < dim; ++iDim) {
	      fin >> sf->xyz(ip,iDim);
      }
      
      if (m_xvec.size() > 0) {
	cf_assert(std::abs(m_angle) > 0.0);
	
	// rotate coordinates
	const CFreal x1 =  sf->xyz(ip,m_xvec[0])*std::cos(m_angle) + sf->xyz(ip,m_xvec[1])*std::sin(m_angle);
	const CFreal y1 = -sf->xyz(ip,m_xvec[0])*std::sin(m_angle) + sf->xyz(ip,m_xvec[1])*std::cos(m_angle);
	sf->xyz(ip,m_xvec[0]) = x1;				   
	sf->xyz(ip,m_xvec[1]) = y1;				   
      }	
      fin >> sf->Tw[ip];
    }
  }

  /////start read 2nd file
  CFLogInfo("NodalStatesExtrapolator::readSurfaceDataextrapolator() => START reading 2nd file " <<
	    fileName2 << ", dim="<< dim << ", nbPoints="<< nbPoints <<"\n");
  
  fin2 >> nbSurf;

  // store all the surface data
  for (CFuint is = 0; is < nbSurf; ++is) {
    //std::string nameSurf = "";
    fin2 >> nameSurf;
    //CFuint nbPoints = 0;
    fin2 >> nbPoints;
    
    CFLogInfo("nbSurf2 = " << is << "/" << nbSurf << ", NameSurf = " <<
	      nameSurf << ", nbPoints = " << nbPoints << "\n");
    //SurfaceData* sf2 = new SurfaceData(); 
    sf2->xyz.resize(nbPoints,dim);
    sf2->Tw.resize(nbPoints);
    
    for (CFuint ip = 0; ip < nbPoints; ++ip) {
      for (CFuint iDim = 0; iDim < dim; ++iDim) {
	fin2 >> sf2->xyz(ip,iDim);
      }
      
      if (m_xvec.size() > 0) {
	cf_assert(std::abs(m_angle) > 0.0);
	
	// rotate coordinates
	const CFreal x1 =  sf2->xyz(ip,m_xvec[0])*std::cos(m_angle) + sf2->xyz(ip,m_xvec[1])*std::sin(m_angle);
	const CFreal y1 = -sf2->xyz(ip,m_xvec[0])*std::sin(m_angle) + sf2->xyz(ip,m_xvec[1])*std::cos(m_angle);
	sf2->xyz(ip,m_xvec[0]) = x1;				   
	sf2->xyz(ip,m_xvec[1]) = y1;				   
      }	
      fin2 >> sf2->Tw[ip];
	  if(ip==10 || ip==20 || ip==30){
	    CFLogInfo("sf->Tw[ip]=" << sf->Tw[ip]<< ", sf2->Tw[ip]=" << sf2->Tw[ip]<<", ip="<<ip<<"\n");
		CFLogInfo("sf->xyz(ip,2)=" << sf->xyz(ip,2)<< ", sf2->xyz(ip,2)=" << sf2->xyz(ip,2)<<", ip="<<ip<<"\n");
	  }
	  sf2->Tw[ip]=sf->Tw[ip]* Coefi1+sf2->Tw[ip]* Coefi2;
    }
    surfaces[is] = (m_extractCoordZID < 0) ?  sf2 : extractLineData(sf2);
  }
  CFLogInfo("sf2->Tw[10]=" << sf2->Tw[10]<< ", sf2->Tw[20]=" << sf2->Tw[20]<<", sf2->Tw[30]=" << sf2->Tw[30]<<"\n");
  CFLogInfo("surfaces[0]->Tw[10]=" << surfaces[0]->Tw[10]<< ", surfaces[0]->Tw[20]=" << surfaces[0]->Tw[20]<<", surfaces[0]->Tw[30]=" << surfaces[0]->Tw[30]<<"\n");
  //CFLogInfo("surfaces[0]->xyz(10,2)=" << surfaces[0]->xyz(10,2)<< ", surfaces[0]->xyz(20,2)=" << surfaces[0]->xyz(20,2)<<", surfaces[0]->xyz(30,2)=" << surfaces[0]->xyz(30,2)<<"\n");
  CFLogInfo("NodalStatesExtrapolator::readSurfaceDataextrapolator() => END reading 2nd file " <<
	    fileName << "\n"); 
}

//////////////////////////////////////////////////////////////////////////////


template <typename DATA>
typename NodalStatesExtrapolator<DATA>::SurfaceData* 
NodalStatesExtrapolator<DATA>::extractLineData(SurfaceData* surface)
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::MathTools;
  using namespace COOLFluiD::Common;
  
  /// @TODO here there might be a BUG: be careful !!!

  // if m_extractCoordZID >= 0 a line distribution is extracted from a {x y z T} distribution for z=0
  //                           with z = x[m_extractCoordZID]
  
  CFreal minZ = MathConsts::CFrealMax();
  const CFuint nbPoints = surface->Tw.size();
  for (CFuint ip = 0; ip < nbPoints; ++ip) {
    minZ = std::min(std::abs(surface->xyz(ip, m_extractCoordZID)), minZ);
  }
  
  CFuint nbPointsOnLine = 0;
  for (CFuint ip = 0; ip < nbPoints; ++ip) {
    if (MathChecks::isEqual(std::abs(surface->xyz(ip, m_extractCoordZID)), minZ)) {
      nbPointsOnLine++;
    }
  }
  
  SurfaceData* newData = new SurfaceData(); 
  newData->xyz.resize(nbPointsOnLine,2);
  newData->Tw.resize(nbPointsOnLine);
  
  CFuint counter = 0;
  for (CFuint ip = 0; ip < nbPoints; ++ip) {
    if (MathChecks::isEqual(std::abs(surface->xyz(ip, m_extractCoordZID)), minZ)) {
      cout << surface->Tw[ip] << endl;
      newData->xyz(counter, XX) = surface->xyz(ip, m_extractCoordXYID[XX]);
      newData->xyz(counter, YY) = surface->xyz(ip, m_extractCoordXYID[YY]);
      newData->Tw[counter] = surface->Tw[ip];
      counter++;
    }
  }
  
  cf_always_assert(counter == nbPointsOnLine);
  
  // remove old SurfaceData
  deletePtr(surface);
  
  //replace with new SurfaceData
  return newData;  
}

//////////////////////////////////////////////////////////////////////////////

template <typename DATA>
void NodalStatesExtrapolator<DATA>::unsetup()
{ 
  CFLog(VERBOSE, "NodalStatesExtrapolator<DATA>::unsetup() => START\n");
 
  Framework::MethodStrategy<DATA>::unsetup();
 
  Common::SwapEmpty(_nodalValuesIDFlags);

  for (CFuint i = 0; i < _mapTrs2NodalValues.size(); ++i) {
    for (CFuint j = 0; j < _mapTrs2NodalValues[i]->size(); ++j) {
      deletePtr((*_mapTrs2NodalValues[i])[j]);
    }
    deletePtr(_mapTrs2NodalValues[i]);
  }

  for (CFuint i = 0; i < _mapNodeID2TrsNodeID.size(); ++i) {
    deletePtr(_mapNodeID2TrsNodeID[i]);
  }

  _mapTrsNameToID.clear();
  m_trsID2LookupState.clear();

  Common::SwapEmpty(_orderedTrsList);
  Common::SwapEmpty(_neighborStates);

  for (CFuint is = 0; is < m_allSurfaces.size(); ++is) {
    const CFuint nbSurf = m_allSurfaces[is].size();
    for (CFuint js = 0; js < nbSurf; ++js) {
      deletePtr(m_allSurfaces[is][js]);
    }
  }
  
  for (CFuint is = 0; is < m_surfaceAtTime.size(); ++is) {
    deletePtr(m_surfaceAtTime[is]);
  }
  
  CFLog(VERBOSE, "NodalStatesExtrapolator<DATA>::unsetup() => END\n");
}

//////////////////////////////////////////////////////////////////////////////

    } // namespace Framework

} // namespace COOLFluiD

//////////////////////////////////////////////////////////////////////////////
