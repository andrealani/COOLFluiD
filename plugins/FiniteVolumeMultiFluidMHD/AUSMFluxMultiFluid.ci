#include "Framework/EquationSetData.hh"
#include "Framework/BaseTerm.hh"
#include "FiniteVolume/FVMCC_PolyRec.hh"
#include "MultiFluidMHD/EulerMFMHDTerm.hh"
#include "Framework/MultiScalarTerm.hh"

//////////////////////////////////////////////////////////////////////////////

namespace COOLFluiD {

  namespace Numerics {

    namespace FiniteVolume {

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
AUSMFluxMultiFluid<UPDATEVAR>::AUSMFluxMultiFluid(const std::string& name) :
  FVMCC_FluxSplitter(name),
  m_updateVarSet(CFNULL),
  m_lData(CFNULL),
  m_rData(CFNULL),
  m_a12(),
  m_mL(),
  m_mR(),
  m_unL(),
  m_unR(),
  m_mflux12(),
  m_p12(),
  m_tempUnitNormal(),
  m_pdata(),
  _rightEv(),
  _leftEv(),
  _eValues(),
  _absEvalues(),
  _absJacob(),
  _jRight(),
  _jLeft(),
  _jacob(),
  _jacobLeftTransf(),
  _jacobRightTransf(),
  _jacobDummy(),
  _EMField_l(),
  _EMField_r(), 
  _Aplus(),
  _Aminus(), 
  _resultEM(),
  _psi_l(),
  _psi_r(),
  _m_i(),
  _statesLR(2)
{
  addConfigOptionsTo(this);

  m_choiceA12 = 1;
  this->setParameter("choiceA12",&m_choiceA12);

  m_useLiouUpdateCoeff = false;
  this->setParameter("useLiouUpdateCoeff",&m_useLiouUpdateCoeff);
  
  m_useMacCormackScaling = true;
  this->setParameter("useMacCormackScaling",&m_useMacCormackScaling);

  m_coeff = 1.;
  this->setParameter("Coeff",&m_coeff);
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
AUSMFluxMultiFluid<UPDATEVAR>::~AUSMFluxMultiFluid()
{
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMFluxMultiFluid<UPDATEVAR>::defineConfigOptions(Config::OptionList& options)
{
  options.template addConfigOption< CFuint >
    ("choiceA12","Way of computing the interface sound speed a12.");

  options.template addConfigOption< bool >
   ("useLiouUpdateCoeff",
    "Flag to choose Liou's way to compute the update coefficient for imposing positivity.");
  
  options.template addConfigOption< bool >
   ("useMacCormackScaling", "Flag to use the scaling of the numerical dissipation in the Steger-Warming of Maxwell equations.");

  options.template addConfigOption< CFreal >
    ("Coeff","Coeff for numerical viscosity in the div cleaning");

}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMFluxMultiFluid<UPDATEVAR>::setup()
{
  using namespace COOLFluiD::Framework;
 
  FVMCC_FluxSplitter::setup();
  
  m_tempUnitNormal.resize(PhysicalModelStack::getActive()->getDim());

  PhysicalModelStack::getActive()->getImplementor()->
    getConvectiveTerm()->resizePhysicalData(m_pdata);
    
  m_updateVarSet = this->getMethodData().getUpdateVar().template d_castTo<UPDATEVAR>();
  cf_assert(m_updateVarSet.isNotNull());
  
  const CFuint dim = PhysicalModelStack::getActive()->getDim();
  const bool is2DHalf = PhysicalModelStack::getActive()->getImplementor()->is2DHalf();
  const CFuint nbSpecies = m_updateVarSet->getModel()->getNbScalarVars(0);
  
  // AUSM scheme related data
  const CFuint nbEqs = Framework::PhysicalModelStack::getActive()->getNbEq();
  m_a12.resize(nbSpecies);
  m_p12.resize(nbSpecies);
  m_mflux12.resize(nbSpecies);
  m_unL.resize(nbSpecies);
  m_unR.resize(nbSpecies);
  m_mL.resize(nbSpecies);
  m_mR.resize(nbSpecies);
  _rightEv.resize(nbEqs, nbEqs);
  _leftEv.resize(nbEqs, nbEqs);
  _eValues.resize(nbEqs);
  _absEvalues.resize(nbEqs);
  _absJacob.resize(nbEqs,nbEqs);
  _jRight.resize(nbEqs,nbEqs);
  _jLeft.resize(nbEqs, nbEqs);
  _jacob.resize(nbEqs, nbEqs);
  _jacobLeftTransf.resize(nbEqs, nbEqs);
  _jacobRightTransf.resize(nbEqs, nbEqs);
  _jacobDummy.resize(nbEqs, nbEqs);
  _EMField_l.resize(8);
  _EMField_r.resize(8); 
  _Aplus.resize(8,8);
  _Aminus.resize(8,8);  
  _resultEM.resize(8);
  if(is2DHalf){
    _psi_l.resize(nbSpecies + 3*nbSpecies + nbSpecies);
    _psi_r.resize(nbSpecies + 3*nbSpecies + nbSpecies);
  }
  else {
    _psi_l.resize(nbSpecies + dim*nbSpecies + nbSpecies);
    _psi_r.resize(nbSpecies + dim*nbSpecies + nbSpecies);
  }
  _m_i.resize(3);
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMFluxMultiFluid<UPDATEVAR>::compute(RealVector& result)
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  
  const EquationSubSysDescriptor& eqSS = PhysicalModelStack::getActive()->getEquationSubSysDescriptor();
  const CFuint totalNbEqs = PhysicalModelStack::getActive()->getNbEq();	// Maxwell's Eqs.+ Multifluid NavierStokes Eqs.
  const CFuint nbEqs = eqSS.getNbEqsSS();  				
  const CFuint iEqSS = eqSS.getEqSS();
   
  vector<RealVector>& pdata = getMethodData().getPolyReconstructor()->getExtrapolatedPhysicaData();
  m_lData = &pdata[LEFT];
  m_rData = &pdata[RIGHT];
  const CFuint dim = PhysicalModelStack::getActive()->getDim();
  const bool is2DHalf = PhysicalModelStack::getActive()->getImplementor()->is2DHalf();
  
  if (nbEqs == totalNbEqs || iEqSS == 1) {
    if (this->getMethodData().useAnalyticalConvJacob()) {
      computeLinearizedAbsJacob();
    }
    
    CFLog(DEBUG_MED, "AUSMFluxMultiFluid::compute() => Fluid iEqSS = " << iEqSS << ", isPerturb " 
	  << getMethodData().isPerturb() << ", iVar = " << getMethodData().iPerturbVar() <<"\n");
    
    // The flow at the freestream is assumed to be one-dimensional
    // calculation of the normal component of velocity for
    // the left and right states
    const RealVector& normal = getMethodData().getUnitNormal();
    const CFuint nbSpecies = m_updateVarSet->getModel()->getNbScalarVars(0);
    const CFuint firstVelocity = m_updateVarSet->getModel()->getFirstScalarVar(1);
    
    for (CFuint ie = 0; ie < nbSpecies; ++ie) {
      m_unL[ie] = 0.0;
      m_unR[ie] = 0.0;
      for (CFuint idim = 0; idim < dim; ++idim) {
        const CFuint currXX = firstVelocity + dim*ie + idim; ///this would work only in 2D and 3D and 2.5 since nz = 0
        m_unL[ie] += (*m_lData)[currXX]*normal[idim];
        m_unR[ie] += (*m_rData)[currXX]*normal[idim];
      }
    }
    
    // Compute speed of the mesh at current quadrature point
    // the normal velocities m_unL and m_unR will be modified accordingly
    this->computeMeshSpeed();
    
    computeMassFlux();      // m_mflux12
  
    //This part is for the MultiFluid euler equations
    computePressureFlux();	//m_p12
    computeMassFluxImpl(result);    
  }
  
  if (nbEqs == totalNbEqs || iEqSS == 0) {
    CFLog(DEBUG_MED, "AUSMFluxMultiFluid::compute() => Maxwell iEqSS = " << iEqSS << ", isPerturb " 
	  << getMethodData().isPerturb() << ", iVar = " << getMethodData().iPerturbVar() <<"\n");
    
    // here there could be the current number of equations if we want
    // different eigenvalues for each set of equations
    const EquationSetData& eqSetEMField = UPDATEVAR::MAXWELLSET::getEqSetData()[0]; //Electromagnetic Field
    const vector<CFuint>& varIDsEMField = eqSetEMField.getEqSetVarIDs();
    
    // const CFuint firstEMField = varIDsEMField[0];  
    const CFuint endEM = varIDsEMField.size();
    
    /// flux splitting scheme for Maxwell's Equations
    //loop to set the electromagnetic variables 
    for (CFuint i = 0; i < endEM; ++i){
      _EMField_l[i] = (*this->m_lData)[i];
      _EMField_r[i] = (*this->m_rData)[i];    
    }
    computeMatrixAplus();
    computeMatrixAminus();
    
    _resultEM = 0.5*_Aplus*_EMField_l + 0.5*_Aminus*_EMField_r;   
    
    for(CFuint iem = 0; iem < endEM; ++iem){
      result[iem] = _resultEM[iem];   
    }    
  }
  
  if (!this->getMethodData().isPerturb()) {
    computeUpdateCoeff();
  }
  
  if(is2DHalf){
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux BX = " << result[0] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux BY = " << result[1] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux BZ = " << result[2] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux EX = " << result[3] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux EY = " << result[4] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux EZ = " << result[5] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux PSI = " << result[6] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux PHI = " << result[7] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux mass = " << result[8] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux mass = " << result[9] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux X-mom = " << result[10] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux Y-mom = " << result[11] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux z-mom = " << result[12] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux X-mom = " << result[13] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux Y-mom = " << result[14] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux z-mom = " << result[15] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux Energy = " << result[16] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux Energy = " << result[17] << "\n");
  }
  else{
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux BX = " << result[0] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux BY = " << result[1] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux BZ = " << result[2] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux EX = " << result[3] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux EY = " << result[4] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux EZ = " << result[5] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux PSI = " << result[6] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux PHI = " << result[7] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux mass = " << result[8] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux mass = " << result[9] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux X-mom = " << result[10] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux Y-mom = " << result[11] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux X-mom = " << result[12] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux Y-mom = " << result[13] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux Energy = " << result[14] << "\n");
   CFLog(VERBOSE,"AUSMFluxMultiFluid::compute --> convFlux Energy = " << result[15] << "\n");
  }
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMFluxMultiFluid<UPDATEVAR>::computeUpdateCoeff()
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  
  CellCenterFVMData& data = this->getMethodData(); 
  GeometricEntity& face = *data.getCurrentFace();
  const CFreal faceArea = socket_faceAreas.getDataHandle()[face.getID()]/
    data.getPolyReconstructor()->nbQPoints();
  const EquationSubSysDescriptor& eqSSD = PhysicalModelStack::getActive()->
    getEquationSubSysDescriptor();
  
  DataHandle<CFreal> updateCoeff = socket_updateCoeff.getDataHandle();
  const CFuint nbEqSS = eqSSD.getTotalNbEqSS();
  //   CFLog(INFO, "AUSMFluxMultiFluid::computeUpdateCoeff() => nbEqSS = " << nbEqSS << "\n");
  for (CFuint i = 0; i < nbEqSS; ++i) {
    // set the ID of the current equation subsystem
    //m_updateVarSet->setEqSS(i);
    
    // left contribution to update coefficient
    const CFuint leftID = face.getState(0)->getLocalID();
    CFreal maxEV = m_updateVarSet->getMaxEigenValue(*m_lData, data.getUnitNormal());
    CFLog(VERBOSE, "AUSMFluxMultiFluid::computeUpdateCoeff() => Max left eigenvalue in EqSS " << i << " is " << maxEV << "\n");
    updateCoeff[leftID*nbEqSS + i] += max(maxEV, 0.)*faceArea;
    
    if (!face.getState(1)->isGhost()) {
      // right contribution to update coefficient
      const CFuint rightID = face.getState(1)->getLocalID();
      m_tempUnitNormal = -1.0*data.getUnitNormal();
      maxEV = m_updateVarSet->getMaxEigenValue(*m_rData,m_tempUnitNormal);
      CFLog(VERBOSE, "AUSMFluxMultiFluid::computeUpdateCoeff() => Max right eigenvalue in EqSS " << i << " is " << maxEV << "\n");
      updateCoeff[rightID*nbEqSS + i] += max(maxEV, 0.)*faceArea;    
    }
  }
}
      
//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMFluxMultiFluid<UPDATEVAR>::computeLiouUpdateCoeff() 
{
  //using namespace std;
  //using namespace COOLFluiD::Framework;

  //CellCenterFVMData& data = this->getMethodData(); 
  //GeometricEntity& face = *data.getCurrentFace();
  //const CFreal faceArea = socket_faceAreas.getDataHandle()[face.getID()]/
    //data.getPolyReconstructor()->nbQPoints();
  
  //const EquationSubSysDescriptor& eqSSD = PhysicalModelStack::getActive()->
    //getEquationSubSysDescriptor();
  
  //DataHandle<CFreal> updateCoeff = socket_updateCoeff.getDataHandle();
  //const CFuint nbEqSS = eqSSD.getTotalNbEqSS();
  //const CFuint dim = PhysicalModelStack::getActive()->getDim();

  //for (CFuint i = 0; i < nbEqSS; ++i) {
    // left contribution to update coefficient
    //const CFuint leftID = face.getState(0)->getLocalID();
    //m_updateVarSet->computePhysicalData(*face.getState(0), m_pdata);
    
    //CFreal vnL = 0.0;
    //for (CFuint idim = 0; idim < dim; ++idim) {
      //const CFuint currXX = UPDATEVAR::PTERM::VX + idim; 
      //vnL += m_pdata[currXX]*m_tempUnitNormal[idim];
    //}
    //CFreal maxEVL = vnL + m_pdata[UPDATEVAR::PTERM::A];
    //const CFreal evMinL = 0.5*(maxEVL - std::abs(maxEVL));

    //CFreal vnR = -vnL;
    //CFreal maxEVR = vnR + m_pdata[UPDATEVAR::PTERM::A];
    //const CFreal evPlusR = 0.5*(maxEVR + std::abs(maxEVR));
    
    //m_updateVarSet->computePhysicalData(*face.getState(1), m_pdata);
    //vnL = 0.0;
    //for (CFuint idim = 0; idim < dim; ++idim) {
      //const CFuint currXX = UPDATEVAR::PTERM::VX + idim; 
      //vnL += m_pdata[currXX]*m_tempUnitNormal[idim];
    //}
    //maxEVL = vnL + m_pdata[UPDATEVAR::PTERM::A];
    //const CFreal evPlusL = 0.5*(maxEVL + std::abs(maxEVL));
    
    //updateCoeff[leftID*nbEqSS + i] += max(evPlusL - evMinL, 0.)*faceArea;
    //vnR = -vnL;
    //maxEVR = vnR + m_pdata[UPDATEVAR::PTERM::A];
    //const CFreal evMinR = 0.5*(maxEVR - std::abs(maxEVR));

    //if (!face.getState(1)->isGhost()) {
      // right contribution to update coefficient
      //const CFuint rightID = face.getState(1)->getLocalID();
      //updateCoeff[rightID*nbEqSS + i] += max(evPlusR - evMinR, 0.)*faceArea;
    //}
  //}
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMFluxMultiFluid<UPDATEVAR>::computeMassFluxImpl(RealVector& result)
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  
  const CFuint dim = PhysicalModelStack::getActive()->getDim();
  const bool is2DHalf = PhysicalModelStack::getActive()->getImplementor()->is2DHalf();
  const RealVector& normal = this->getMethodData().getUnitNormal();
  const CFuint nbSpecies = m_updateVarSet->getModel()->getNbScalarVars(0);
  const CFuint firstVelocity = m_updateVarSet->getModel()->getFirstScalarVar(1); 
  const CFuint firstTemperature = m_updateVarSet->getModel()->getFirstScalarVar(2);
  const CFuint endEM = 8; 
  
  // calculation of the dimensional numerical fluxes at the interface
  if (m_mflux12 > 0.0) { // LEFT CASE

    for (CFuint ie = 0; ie < nbSpecies; ++ie) {

      _psi_l[ie] = 1;      
      result[endEM + ie] = m_mflux12[ie];
      
      //loop to set the velocities inside Psi
      if(!is2DHalf) {
        for (CFuint i = 0; i < dim; ++i) {
          _psi_l[nbSpecies + ie*dim + i] =  (*this->m_lData)[firstVelocity + ie*dim + i];
          result[endEM + nbSpecies + ie*dim + i] = m_mflux12[ie]*_psi_l[nbSpecies + ie*dim + i] + m_p12[ie]*normal[i];
        }
      }
      else {
        const CFuint dim2DHalf = 3;
        for (CFuint i = 0; i < dim2DHalf; ++i) {
          if( i != 2) { // x,y-direction
            _psi_l[nbSpecies + ie*dim2DHalf + i] =  (*this->m_lData)[firstVelocity + ie*dim2DHalf + i];
            result[endEM + nbSpecies + ie*dim2DHalf + i] = m_mflux12[ie]*_psi_l[nbSpecies + ie*dim2DHalf + i] + m_p12[ie]*normal[i];
          }
          else { // z-direction
            CFreal nz = 0;
            _psi_l[nbSpecies + ie*dim2DHalf + i] =  (*this->m_lData)[firstVelocity + ie*dim2DHalf + i];
            result[endEM + nbSpecies + ie*dim2DHalf + i] = m_mflux12[ie]*_psi_l[nbSpecies + ie*dim2DHalf + i] + m_p12[ie]*nz;
          }
        }
      }
      //enthalpy
      if(!is2DHalf) { //Default case
        _psi_l[nbSpecies + nbSpecies*dim + ie] = (*this->m_lData)[firstTemperature + 4*ie + 3];
        result[endEM + nbSpecies + nbSpecies*dim + ie] = m_mflux12[ie]*_psi_l[nbSpecies + nbSpecies*dim + ie];
      }
      else { // when it is 2D half
        _psi_l[nbSpecies + nbSpecies*3 + ie] = (*this->m_lData)[firstTemperature + 4*ie + 3];
        result[endEM + nbSpecies + nbSpecies*3 + ie] = m_mflux12[ie]*_psi_l[nbSpecies + nbSpecies*3 + ie];
      }
    }
    //if(!getMethodData().isPerturb()) {
      //cout <<"Left case: \n";
      //cout <<"result = " << result;
      //cout <<"\n";
    //}
  }
  
  else { // RIGHT CASE
        
    for (CFuint ie = 0; ie < nbSpecies; ++ie) {
      
      _psi_r[ie] = 1;      
      result[endEM + ie] = m_mflux12[ie];
      
      //loop to set the velocities inside Psi
      if(!is2DHalf) {
        for (CFuint i = 0; i < dim; ++i) {
          _psi_r[nbSpecies + ie*dim + i] =  (*this->m_rData)[firstVelocity + ie*dim + i];
          result[endEM + nbSpecies + ie*dim + i] = m_mflux12[ie]*_psi_r[nbSpecies + ie*dim + i] + m_p12[ie]*normal[i];
        }
      }
      else {
        const CFuint dim2DHalf = 3;
        for (CFuint i = 0; i < dim2DHalf; ++i) {
          if( i != 2) { // x,y-direction
            _psi_r[nbSpecies + ie*dim2DHalf + i] =  (*this->m_rData)[firstVelocity + ie*dim2DHalf + i];
            result[endEM + nbSpecies + ie*dim2DHalf + i] = m_mflux12[ie]*_psi_r[nbSpecies + ie*dim2DHalf + i] + m_p12[ie]*normal[i];
          }
          else { // z-direction
            CFreal nz = 0;
            _psi_r[nbSpecies + ie*dim2DHalf + i] =  (*this->m_rData)[firstVelocity + ie*dim2DHalf + i];
            result[endEM + nbSpecies + ie*dim2DHalf + i] = m_mflux12[ie]*_psi_r[nbSpecies + ie*dim2DHalf + i] + m_p12[ie]*nz;
          }
        }
      }
      //total enthalpy
      if(!is2DHalf) { //Default case
        _psi_r[nbSpecies + nbSpecies*dim + ie] = (*this->m_rData)[firstTemperature + 4*ie + 3];
        result[endEM + nbSpecies + nbSpecies*dim + ie] = m_mflux12[ie]*_psi_r[nbSpecies + nbSpecies*dim + ie] ;
      }
      else { // when it is 2D half
        _psi_r[nbSpecies + nbSpecies*3 + ie] = (*this->m_rData)[firstTemperature + 4*ie + 3];
        result[endEM + nbSpecies + nbSpecies*3 + ie] = m_mflux12[ie]*_psi_r[nbSpecies + nbSpecies*3 + ie] ;
      }
    }
    //if(!getMethodData().isPerturb()) {
      //cout <<"Right case: \n";
      //cout <<"result = " << result; 
      //cout <<"\n";        
    //}
  } 
}


//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMFluxMultiFluid<UPDATEVAR>::computeInterfaceSoundSpeed()
{
  // the user must choose one of the following 3 ways of calculation of the
  // interface speed of sound, a12
  this->m_a12 = 0.0;
  switch(this->m_choiceA12) {
  case 1:
    computeSoundSpeed1();
    break;
  case 2:
    computeSoundSpeed2();
    break;
  case 3:
    computeSoundSpeed3();
    break;
  case 4:
    computeSoundSpeed4();
    break;
  case 5:
    computeSoundSpeed5();
    break;
  default:
    computeSoundSpeed1();
    break;
  }
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMFluxMultiFluid<UPDATEVAR>::computeSoundSpeed1()
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  
  const CFuint nbSpecies = m_updateVarSet->getModel()->getNbScalarVars(0);
  const CFuint firstTemperature = m_updateVarSet->getModel()->getFirstScalarVar(2);
  const CFreal gamma = m_updateVarSet->getModel()->getGamma();
  const CFreal gammaMinus1 = gamma - 1.0;
  
  for (CFuint ie = 0; ie < nbSpecies; ++ie){

    const CFreal hL = (*this->m_lData)[firstTemperature + 4*ie + 3];
    const CFreal hR = (*this->m_rData)[firstTemperature + 4*ie + 3];

    // 1st Way of calculation of the interface speed of sound, a12,
    // suggested by Liou in his AIAA 2003-4116 paper

    const CFreal aCritL = sqrt( (2.0*gammaMinus1/(gamma+1.0))*hL);
    const CFreal aCritR = sqrt( (2.0*gammaMinus1/(gamma+1.0))*hR);

    const CFreal acL = (aCritL*aCritL)/max(aCritL, this->m_unL[ie]);
    const CFreal acR = (aCritR*aCritR)/max(aCritR, -this->m_unR[ie]);
    this->m_a12[ie] = min(acL, acR);		      //Array with the speed of sound of the different species
  }
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMFluxMultiFluid<UPDATEVAR>::computeSoundSpeed2()
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  
  const CFuint nbSpecies = m_updateVarSet->getModel()->getNbScalarVars(0);
  const CFuint firstTemperature = m_updateVarSet->getModel()->getFirstScalarVar(2);

  // 2nd Way of calculation of the interface speed of sound, a12,
  // by simply taking the arithmetic average of the speeds of sounds
  // at the left and right states
  
  for (CFuint ie = 0; ie < nbSpecies; ++ie){  
    const CFreal aL = (*this->m_lData)[firstTemperature + 4*ie + 2];
    const CFreal aR = (*this->m_rData)[firstTemperature + 4*ie + 2];
    this->m_a12[ie] = 0.5 * (aL + aR);
  }
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMFluxMultiFluid<UPDATEVAR>::computeSoundSpeed3()
{
  using namespace std;
  using namespace COOLFluiD::Framework;

  // 3rd Way of calculation of the interface speed of sound, a12,
  // by simply taking the geometric mean of the speeds of sounds
  // at the left and right states
  
  const CFuint nbSpecies = m_updateVarSet->getModel()->getNbScalarVars(0);
  const CFuint firstTemperature = m_updateVarSet->getModel()->getFirstScalarVar(2);  
  
  for (CFuint ie = 0; ie < nbSpecies; ++ie){  
    const CFreal aL = (*this->m_lData)[firstTemperature + 4*ie + 2];
    const CFreal aR = (*this->m_rData)[firstTemperature + 4*ie + 2];
    this->m_a12[ie] = sqrt(aL*aR);
  }
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMFluxMultiFluid<UPDATEVAR>::computeSoundSpeed4()
{
  using namespace std;
  using namespace COOLFluiD::Framework;

  // Way of calculation of the interface speed of sound, a12,
  // in case of TCNEQ suggested by Jin Wook Lee in his PhD thesis
  
  const CFuint nbSpecies = m_updateVarSet->getModel()->getNbScalarVars(0);
//   const CFuint firstSpecies = m_updateVarSet->getModel()->getFirstScalarVar(0);
  const CFuint firstVelocity = m_updateVarSet->getModel()->getFirstScalarVar(1);  
  const CFuint dim = PhysicalModelStack::getActive()->getDim();
  const bool is2DHalf = PhysicalModelStack::getActive()->getImplementor()->is2DHalf();
  const CFuint firstTemperature = m_updateVarSet->getModel()->getFirstScalarVar(2);
  const CFreal gamma = m_updateVarSet->getModel()->getGamma();
  
  for (CFuint ie = 0; ie < nbSpecies; ++ie){ 
    
    CFreal V2L = 0;		//square of velocity
    CFreal V2R = 0;
    
    for (CFuint i = 0; i < dim; ++i){      
      V2L = V2L + (*this->m_lData)[firstVelocity + dim*ie + i]*(*this->m_lData)[firstVelocity + dim*ie + i];
      V2R = V2R + (*this->m_rData)[firstVelocity + dim*ie + i]*(*this->m_rData)[firstVelocity + dim*ie + i];
    }
    if (is2DHalf) { // summing the z component in case of 2D Half
      V2L = V2L + (*this->m_lData)[firstVelocity + 3*ie + 2]*(*this->m_lData)[firstVelocity + 3*ie + 2];
      V2R = V2R + (*this->m_rData)[firstVelocity + 3*ie + 2]*(*this->m_rData)[firstVelocity + 3*ie + 2];
    }
    
    const CFreal kL = 0.5*V2L;
    const CFreal kR = 0.5*V2R;
    const CFreal hsL = (*this->m_lData)[firstTemperature + 4*ie + 3] - kL + 0.5*m_unL[ie]*m_unL[ie];
    const CFreal hsR = (*this->m_rData)[firstTemperature + 4*ie + 3]- kR + 0.5*m_unR[ie]*m_unR[ie];
    const CFreal Hnormal = 0.5*(hsL + hsR);
    const CFreal c1 = (gamma-1.)/(gamma*m_unR[ie])- (gamma-1.)/(gamma*m_unL[ie]);
    const CFreal c2 = (gamma+1.)/(gamma*m_unL[ie])- (gamma+1.)/(gamma*m_unR[ie]);
    const CFreal as = sqrt(2.*Hnormal*std::abs(c1)/std::abs(c2));
    this->m_a12[ie] = ((m_unL[ie] + m_unR[ie]) < 0.0) ? as*as/max(std::abs(m_unR[ie]),as) :
      as*as/max(std::abs(m_unL[ie]),as);
    // this->m_a12 = min(as*as/max(std::abs(m_unR),as), as*as/max(std::abs(m_unL),as));
  }
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMFluxMultiFluid<UPDATEVAR>::computeSoundSpeed5()
{
  using namespace std;
  using namespace COOLFluiD::Framework;

  // Way of calculation of the interface speed of sound, a12,
  // in case of TCNEQ suggested by Jin Wook Lee in his PhD thesis
  // unused //  const CFreal aL = (*this->m_lData)[UPDATEVAR::PTERM::A];
  // unused //   const CFreal aR = (*this->m_rData)[UPDATEVAR::PTERM::A];

  // Way of calculation of the interface speed of sound, a12,
  // suggested by Liou in his AIAA 2003-4116 paper but applied to
  // NEQ flows (Selmin's lecture)
  RealVector& lData = (*this->m_lData);
  RealVector& rData = (*this->m_rData);
  
  const CFuint nbSpecies = m_updateVarSet->getModel()->getNbScalarVars(0);
  const CFuint firstSpecies = m_updateVarSet->getModel()->getFirstScalarVar(0);
//   const CFuint firstVelocity = m_updateVarSet->getModel()->getFirstScalarVar(1);  
//   const CFuint dim = PhysicalModelStack::getActive()->getDim();
  const CFuint firstTemperature = m_updateVarSet->getModel()->getFirstScalarVar(2);
  const CFreal gamma = m_updateVarSet->getModel()->getGamma();
  const CFreal K_gas = m_updateVarSet->getModel()->getK();
  const CFreal m_e = m_updateVarSet->getModel()->getMolecularMass1();
  const CFreal m_n = m_updateVarSet->getModel()->getMolecularMass2();
  const CFreal m_p = m_updateVarSet->getModel()->getMolecularMass3(); 
  
  //set the molar masses of the species (should be changed in the future)
  _m_i[0] = m_e;
  _m_i[1] = m_n;
  _m_i[2] = m_p;
  
   
  for (CFuint ie = 0; ie < nbSpecies; ++ie){
    
    const CFreal R_gas = K_gas/_m_i[ie];
    const CFreal c_v = (1/(gamma-1))*(R_gas);//specific heat for constant volumen

    const CFreal eL = c_v*lData[firstTemperature + 4*ie];//internal energy (LEFT)
    const CFreal eR = c_v*rData[firstTemperature + 4*ie];//internal energy (RIGHT)

    const CFreal gBarL = 1. + lData[firstTemperature + 4*ie + 1]/
      (eL*lData[UPDATEVAR::PTERM::RHO]*lData[firstSpecies + ie]);
    const CFreal gBarMinus1L = gamma*(gBarL - 1.0);

    const CFreal gBarR = 1. + rData[firstTemperature + 4*ie + 1]/
      (eR*rData[UPDATEVAR::PTERM::RHO]*rData[firstSpecies + ie]);
    const CFreal gBarMinus1R = gamma*(gBarR - 1.0);

    const CFreal hLL = lData[firstTemperature + 4*ie + 3];
    const CFreal hRR = rData[firstTemperature + 4*ie + 3];
    const CFreal aCritLL2 = 2.0*gBarMinus1L/(2.*gBarL + gBarMinus1L)*hLL;
    const CFreal aCritRR2 = 2.0*gBarMinus1R/(2.*gBarR + gBarMinus1R)*hRR;
    const CFreal acLL = aCritLL2/max(sqrt(aCritLL2), this->m_unL[ie]);
    const CFreal acRR = aCritRR2/max(sqrt(aCritRR2), -this->m_unR[ie]);
    this->m_a12[ie] = min(acLL, acRR);
  }
}
      
//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMFluxMultiFluid<UPDATEVAR>::computeLeftJacobian()
{  
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::Common;
  
  CellCenterFVMData& data = this->getMethodData(); 
  GeometricEntity& face = *data.getCurrentFace();
  State *const leftState = face.getState(LEFT);
  RealVector& pData = PhysicalModelStack::getActive()->getImplementor()->
    getConvectiveTerm()->getPhysicalData();
  getMethodData().getUpdateVar()->computePhysicalData(*leftState, pData);
  getMethodData().getSolutionVar()->computeProjectedJacobian(data.getUnitNormal(), _jacob); 
  _jLeft = 0.5*(_jacob + _absJacob);
  
  // computeTransformMatrix(leftState);
  // _lFluxJacobian = _jLeft*_jacobDummy;
  
  SafePtr<VarSetMatrixTransformer>  vs = 
    getMethodData().getUpdateToSolutionInUpdateMatTrans();
  vs->setMatrix(*leftState);
  const RealMatrix& dUdP = *vs->getMatrix();  
  _lFluxJacobian = _jLeft*dUdP;
}
      
//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMFluxMultiFluid<UPDATEVAR>::computeRightJacobian()
{ 
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::Common;
  
  CellCenterFVMData& data = this->getMethodData(); 
  GeometricEntity& face = *data.getCurrentFace();
  State *const rightState = face.getState(RIGHT);
  RealVector& pData = PhysicalModelStack::getActive()->getImplementor()->
    getConvectiveTerm()->getPhysicalData();
  getMethodData().getUpdateVar()->computePhysicalData(*rightState, pData);
  getMethodData().getSolutionVar()->computeProjectedJacobian(data.getUnitNormal(), _jacob);
  _jRight = 0.5*(_jacob - _absJacob);
  
  // computeTransformMatrix(rightState);
  //_rFluxJacobian = _jRight*_jacobDummy;
  
  SafePtr<VarSetMatrixTransformer>  vs = 
    getMethodData().getUpdateToSolutionInUpdateMatTrans();
  vs->setMatrix(*rightState);
  const RealMatrix& dUdP = *vs->getMatrix();
  _rFluxJacobian = _jRight*dUdP;
}
      
//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMFluxMultiFluid<UPDATEVAR>::computeLinearizedAbsJacob()
{  
  using namespace std;
  using namespace COOLFluiD::Framework;
  
  CellCenterFVMData& data = this->getMethodData(); 
  
  // linearization in update states
  _statesLR[0] = &data.getPolyReconstructor()->getCurrLeftState();
  _statesLR[1] = &data.getPolyReconstructor()->getCurrRightState();
  
  getMethodData().getJacobianLinearizer()->linearize(_statesLR);
  
  // set the eigenvectors and eigenvalues of the linearized jacobian
  getMethodData().getSolutionVar()->computeEigenValuesVectors(_rightEv,
							      _leftEv,
							      _eValues,
							      data.getUnitNormal());
  
  // set the abs of the  eigen values (the implementation of this
  // function change if there are entropy or carbuncle fixes)
  _absEvalues = abs(_eValues);
  
  // abs of the jacobian
  _absJacob = _rightEv*(_absEvalues*_leftEv);
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMFluxMultiFluid<UPDATEVAR>::computeMatrixAplus()
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  
  const CFuint dim = PhysicalModelStack::getActive()->getDim();
  const RealVector& normal = getMethodData().getUnitNormal();
  const CFreal gamma = m_updateVarSet->getModel()->getDivBCleaningConst();	//DivB cleaning technique constant
  const CFreal chi = m_updateVarSet->getModel()->getDivECleaningConst();
  const CFreal c_e = m_updateVarSet->getModel()->getLightSpeed();//speed of light
  CFreal factor1, factor2, factor3;
  
  
  if(m_useMacCormackScaling){
    factor1 = 1;
    factor2 = c_e*c_e;
    factor3 = m_coeff*c_e*c_e;
  }
  else{
    factor1 = c_e;
    factor2 = c_e;
    factor3 = c_e;
  }
  
  if(dim == 2){
    _Aplus(0,0) = (normal[1]*normal[1] + gamma*normal[0]*normal[0])*factor1; //flag2
    _Aplus(0,1) = (gamma - 1)*normal[0]*normal[1]*factor1; //flag2
    _Aplus(0,2) = 0;
    _Aplus(0,3) = 0;
    _Aplus(0,4) = 0;
    _Aplus(0,5) = normal[1];
    _Aplus(0,6) = gamma*gamma*normal[0]; 
    _Aplus(0,7) = 0; 

    _Aplus(1,0) = (gamma - 1)*normal[0]*normal[1]*factor1; //flag2;
    _Aplus(1,1) = (normal[0]*normal[0] + gamma*normal[1]*normal[1])*factor1; //flag2
    _Aplus(1,2) = 0;
    _Aplus(1,3) = 0;
    _Aplus(1,4) = 0;
    _Aplus(1,5) = -normal[0];
    _Aplus(1,6) = gamma*gamma*normal[1]; 
    _Aplus(1,7) = 0; 

    _Aplus(2,0) = 0;
    _Aplus(2,1) = 0;
    _Aplus(2,2) = factor1; //flag2
    _Aplus(2,3) = -normal[1];
    _Aplus(2,4) = normal[0];
    _Aplus(2,5) = 0;
    _Aplus(2,6) = 0; 
    _Aplus(2,7) = 0; 

    _Aplus(3,0) = 0;
    _Aplus(3,1) = 0;
    _Aplus(3,2) = -normal[1]*c_e*c_e;
    _Aplus(3,3) = (normal[1]*normal[1] + chi*normal[0]*normal[0])*factor2; //flag
    _Aplus(3,4) = (chi - 1)*normal[0]*normal[1]*factor2; //flag
    _Aplus(3,5) = 0;
    _Aplus(3,6) = 0;  
    _Aplus(3,7) = chi*chi*normal[0]*c_e*c_e;  
    
    _Aplus(4,0) = 0;
    _Aplus(4,1) = 0;
    _Aplus(4,2) = normal[0]*c_e*c_e;
    _Aplus(4,3) = (chi -1)*normal[0]*normal[1]*factor2; //flag
    _Aplus(4,4) = (normal[0]*normal[0] + chi*normal[1]*normal[1])*factor2; //flag
    _Aplus(4,5) = 0;
    _Aplus(4,6) = 0; 
    _Aplus(4,7) = chi*chi*normal[1]*c_e*c_e;  

    _Aplus(5,0) = normal[1]*c_e*c_e;
    _Aplus(5,1) = -normal[0]*c_e*c_e;
    _Aplus(5,2) = 0;
    _Aplus(5,3) = 0;
    _Aplus(5,4) = 0;
    _Aplus(5,5) = factor2; //flag 
    _Aplus(5,6) = 0; 
    _Aplus(5,7) = 0; 
    
    _Aplus(6,0) = normal[0]*c_e*c_e;
    _Aplus(6,1) = normal[1]*c_e*c_e;
    _Aplus(6,2) = 0;
    _Aplus(6,3) = 0;
    _Aplus(6,4) = 0;
    _Aplus(6,5) = 0;  
    _Aplus(6,6) = gamma*factor3;
    _Aplus(6,7) = 0;
    
    _Aplus(7,0) = 0;
    _Aplus(7,1) = 0;
    _Aplus(7,2) = 0;
    _Aplus(7,3) = normal[0];
    _Aplus(7,4) = normal[1];
    _Aplus(7,5) = 0; 
    _Aplus(7,6) = 0; 
    _Aplus(7,7) = chi*factor1; //flag2  
  }
  if(dim == 3){
    _Aplus(0,0) = (1 + normal[0]*normal[0]*(gamma - 1));
    _Aplus(0,1) = (gamma - 1)*normal[0]*normal[1];
    _Aplus(0,2) = (gamma - 1)*normal[0]*normal[2];
    _Aplus(0,3) = 0;
    _Aplus(0,4) = -normal[2];
    _Aplus(0,5) = normal[1];
    _Aplus(0,6) = gamma*gamma*normal[0]; 
    _Aplus(0,7) = 0; 

    _Aplus(1,0) = (gamma - 1)*normal[0]*normal[1];
    _Aplus(1,1) = (1 + normal[1]*normal[1]*(gamma - 1));
    _Aplus(1,2) = (gamma - 1)*normal[1]*normal[2];
    _Aplus(1,3) = normal[2];
    _Aplus(1,4) = 0;
    _Aplus(1,5) = -normal[0];
    _Aplus(1,6) = gamma*gamma*normal[1]; 
    _Aplus(1,7) = 0; 

    _Aplus(2,0) = (gamma - 1)*normal[0]*normal[2];
    _Aplus(2,1) = (gamma - 1)*normal[1]*normal[2];
    _Aplus(2,2) = (1 + normal[2]*normal[2]*(gamma - 1));
    _Aplus(2,3) = -normal[1];
    _Aplus(2,4) = normal[0];
    _Aplus(2,5) = 0;
    _Aplus(2,6) = gamma*gamma*normal[2]; 
    _Aplus(2,7) = 0; 

    _Aplus(3,0) = 0; 
    _Aplus(3,1) = normal[2]*c_e*c_e; 
    _Aplus(3,2) = -normal[1]*c_e*c_e;
    _Aplus(3,3) = (1 + normal[0]*normal[0]*(chi - 1))*c_e*c_e;
    _Aplus(3,4) = (chi - 1)*normal[0]*normal[1]*c_e*c_e;
    _Aplus(3,5) = (chi - 1)*normal[0]*normal[2]*c_e*c_e; 
    _Aplus(3,6) = 0; 
    _Aplus(3,7) = chi*chi*normal[0]*c_e*c_e;

    _Aplus(4,0) = -normal[2]*c_e*c_e;
    _Aplus(4,1) = 0;
    _Aplus(4,2) = normal[0]*c_e*c_e;
    _Aplus(4,3) = (chi - 1)*normal[0]*normal[1]*c_e*c_e;
    _Aplus(4,4) = (1 + normal[1]*normal[1]*(chi - 1))*c_e*c_e;
    _Aplus(4,5) = (chi - 1)*normal[1]*normal[2]*c_e*c_e;
    _Aplus(4,6) = 0; 
    _Aplus(4,7) = chi*chi*normal[1]*c_e*c_e; 

    _Aplus(5,0) = normal[1]*c_e*c_e;
    _Aplus(5,1) = -normal[0]*c_e*c_e;
    _Aplus(5,2) = 0;
    _Aplus(5,3) = (chi - 1)*normal[0]*normal[2]*c_e*c_e;
    _Aplus(5,4) = (chi - 1)*normal[1]*normal[2]*c_e*c_e;
    _Aplus(5,5) = (1 + normal[2]*normal[2]*(chi - 1))*c_e*c_e;
    _Aplus(5,6) = 0; 
    _Aplus(5,7) = chi*chi*normal[2]*c_e*c_e; 
    
    _Aplus(6,0) = normal[0]*c_e*c_e;
    _Aplus(6,1) = normal[1]*c_e*c_e;
    _Aplus(6,2) = normal[2]*c_e*c_e;
    _Aplus(6,3) = 0;
    _Aplus(6,4) = 0;
    _Aplus(6,5) = 0; 
    _Aplus(6,6) = gamma*c_e*c_e; 
    _Aplus(6,7) = 0;
    
    _Aplus(7,0) = 0;
    _Aplus(7,1) = 0;
    _Aplus(7,2) = 0;
    _Aplus(7,3) = normal[0];
    _Aplus(7,4) = normal[1];
    _Aplus(7,5) = normal[2]; 
    _Aplus(7,6) = 0; 
    _Aplus(7,7) = chi;
  }
}
//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMFluxMultiFluid<UPDATEVAR>::computeMatrixAminus()
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  
  const CFuint dim = PhysicalModelStack::getActive()->getDim();
  const RealVector& normal = getMethodData().getUnitNormal();
  const CFreal gamma = m_updateVarSet->getModel()->getDivBCleaningConst();	//DivB cleaning technique constant
  const CFreal chi = m_updateVarSet->getModel()->getDivECleaningConst();
  const CFreal c_e = m_updateVarSet->getModel()->getLightSpeed();//speed of light
  CFreal factor1, factor2, factor3;
  
  
  if(m_useMacCormackScaling){
    factor1 = 1;
    factor2 = c_e*c_e;
    factor3 = m_coeff*c_e*c_e;
  }
  else{
    factor1 = c_e;
    factor2 = c_e;
    factor3 = c_e;
  }

  if(dim == 2){
    _Aminus(0,0) = -(normal[1]*normal[1] + gamma*normal[0]*normal[0])*factor1; //flag2
    _Aminus(0,1) = (1 - gamma)*normal[0]*normal[1]*factor1; //flag2
    _Aminus(0,2) = 0;
    _Aminus(0,3) = 0;
    _Aminus(0,4) = 0;
    _Aminus(0,5) = normal[1];
    _Aminus(0,6) = gamma*gamma*normal[0]; 
    _Aminus(0,7) = 0; 

    _Aminus(1,0) = (1 - gamma)*normal[0]*normal[1]*factor1; //flag2
    _Aminus(1,1) = -(normal[0]*normal[0] + gamma*normal[1]*normal[1])*factor1; //flag2
    _Aminus(1,2) = 0;
    _Aminus(1,3) = 0;
    _Aminus(1,4) = 0;
    _Aminus(1,5) = -normal[0];
    _Aminus(1,6) = gamma*gamma*normal[1]; 
    _Aminus(1,7) = 0; 

    _Aminus(2,0) = 0;
    _Aminus(2,1) = 0;
    _Aminus(2,2) = factor1; //flag2
    _Aminus(2,3) = -normal[1];
    _Aminus(2,4) = normal[0];
    _Aminus(2,5) = 0;
    _Aminus(2,6) = 0;
    _Aminus(2,7) = 0; 

    _Aminus(3,0) = 0;
    _Aminus(3,1) = 0;
    _Aminus(3,2) = -normal[1]*c_e*c_e;
    _Aminus(3,3) = -(normal[1]*normal[1] + chi*normal[0]*normal[0])*factor2; //flag
    _Aminus(3,4) = (1 - chi)*normal[0]*normal[1]*factor2; //flag
    _Aminus(3,5) = 0;
    _Aminus(3,6) = 0;  
    _Aminus(3,7) = chi*chi*normal[0]*c_e*c_e;  
    
    _Aminus(4,0) = 0;
    _Aminus(4,1) = 0;
    _Aminus(4,2) = normal[0]*c_e*c_e;
    _Aminus(4,3) = (1 - chi)*normal[0]*normal[1]*factor2; //flag
    _Aminus(4,4) = -(normal[0]*normal[0] + chi*normal[1]*normal[1])*factor2; //flag
    _Aminus(4,5) = 0;
    _Aminus(4,6) = 0; 
    _Aminus(4,7) = chi*chi*normal[1]*c_e*c_e;  

    _Aminus(5,0) = normal[1]*c_e*c_e;
    _Aminus(5,1) = -normal[0]*c_e*c_e;
    _Aminus(5,2) = 0;
    _Aminus(5,3) = 0;
    _Aminus(5,4) = 0;
    _Aminus(5,5) = -1*factor2; //flag 
    _Aminus(5,6) = 0; 
    _Aminus(5,7) = 0; 
    
    _Aminus(6,0) = normal[0]*c_e*c_e;
    _Aminus(6,1) = normal[1]*c_e*c_e;
    _Aminus(6,2) = 0;
    _Aminus(6,3) = 0;
    _Aminus(6,4) = 0;
    _Aminus(6,5) = 0;
    _Aminus(6,6) = -gamma*factor3;
    _Aminus(6,7) = 0;
    
    _Aminus(7,0) = 0;
    _Aminus(7,1) = 0;
    _Aminus(7,2) = 0;
    _Aminus(7,3) = normal[0];
    _Aminus(7,4) = normal[1];
    _Aminus(7,5) = 0; 
    _Aminus(7,6) = 0; 
    _Aminus(7,7) = -chi*factor1; //flag2  
  }
  if(dim == 3){
    _Aminus(0,0) = -(1 + normal[0]*normal[0]*(gamma - 1));
    _Aminus(0,1) = -(gamma - 1)*normal[0]*normal[1];
    _Aminus(0,2) = -(gamma - 1)*normal[0]*normal[2];
    _Aminus(0,3) = 0;
    _Aminus(0,4) = -normal[2];
    _Aminus(0,5) = normal[1];
    _Aminus(0,6) = gamma*gamma*normal[0]; 
    _Aminus(0,7) = 0; 

    _Aminus(1,0) = -(gamma - 1)*normal[0]*normal[1];
    _Aminus(1,1) = -(1 + normal[1]*normal[1]*(gamma - 1));
    _Aminus(1,2) = -(gamma - 1)*normal[1]*normal[2];
    _Aminus(1,3) = normal[2];
    _Aminus(1,4) = 0;
    _Aminus(1,5) = -normal[0];
    _Aminus(1,6) = gamma*gamma*normal[1]; 
    _Aminus(1,7) = 0; 

    _Aminus(2,0) = -(gamma - 1)*normal[0]*normal[2];
    _Aminus(2,1) = -(gamma - 1)*normal[1]*normal[2];
    _Aminus(2,2) = -(1 + normal[2]*normal[2]*(gamma - 1));
    _Aminus(2,3) = -normal[1];
    _Aminus(2,4) = normal[0];
    _Aminus(2,5) = 0;
    _Aminus(2,6) = gamma*gamma*normal[2]; 
    _Aminus(2,7) = 0; 

    _Aminus(3,0) = 0; 
    _Aminus(3,1) = normal[2]*c_e*c_e; 
    _Aminus(3,2) = -normal[1]*c_e*c_e;
    _Aminus(3,3) = -(1 + normal[0]*normal[0]*(chi - 1))*c_e*c_e;
    _Aminus(3,4) = -(chi - 1)*normal[0]*normal[1]*c_e*c_e;
    _Aminus(3,5) = -(chi - 1)*normal[0]*normal[2]*c_e*c_e; 
    _Aminus(3,6) = 0; 
    _Aminus(3,7) = chi*chi*normal[0]*c_e*c_e;

    _Aminus(4,0) = -normal[2]*c_e*c_e;
    _Aminus(4,1) = 0;
    _Aminus(4,2) = normal[0]*c_e*c_e;
    _Aminus(4,3) = -(chi - 1)*normal[0]*normal[1]*c_e*c_e;
    _Aminus(4,4) = -(1 + normal[1]*normal[1]*(chi - 1))*c_e*c_e;
    _Aminus(4,5) = -(chi - 1)*normal[1]*normal[2]*c_e*c_e;
    _Aminus(4,6) = 0; 
    _Aminus(4,7) = chi*chi*normal[1]*c_e*c_e; 

    _Aminus(5,0) = normal[1]*c_e*c_e;
    _Aminus(5,1) = -normal[0]*c_e*c_e;
    _Aminus(5,2) = 0;
    _Aminus(5,3) = -(chi - 1)*normal[0]*normal[2]*c_e*c_e;
    _Aminus(5,4) = -(chi - 1)*normal[1]*normal[2]*c_e*c_e;
    _Aminus(5,5) = -(1 + normal[2]*normal[2]*(chi - 1))*c_e*c_e;
    _Aminus(5,6) = 0; 
    _Aminus(5,7) = chi*chi*normal[2]*c_e*c_e; 
    
    _Aminus(6,0) = normal[0]*c_e*c_e;
    _Aminus(6,1) = normal[1]*c_e*c_e;
    _Aminus(6,2) = normal[2]*c_e*c_e;
    _Aminus(6,3) = 0;
    _Aminus(6,4) = 0;
    _Aminus(6,5) = 0; 
    _Aminus(6,6) = -gamma*c_e*c_e; 
    _Aminus(6,7) = 0;
    
    _Aminus(7,0) = 0;
    _Aminus(7,1) = 0;
    _Aminus(7,2) = 0;
    _Aminus(7,3) = normal[0];
    _Aminus(7,4) = normal[1];
    _Aminus(7,5) = normal[2]; 
    _Aminus(7,6) = 0; 
    _Aminus(7,7) = -chi;  
  }  
}


//////////////////////////////////////////////////////////////////////////////

    } // namespace FiniteVolume

  } // namespace Numerics

} // namespace COOLFluiD

//////////////////////////////////////////////////////////////////////////////
