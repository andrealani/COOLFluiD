"""
Spherical Shell Q2 Mesh Generator

This script generates a 3D mesh of a spherical shell using:
1. Geodesic polyhedron refinement for the inner surface (with Q2 triangles)
2. Radial extrusion to create prismatic Q2 elements

Author: Rayan Dhib
Date: October 2025
"""

import math
from numpy import pi, cos, sin, sqrt
import argparse
from typing import Dict, List, Tuple


# ============================================================================
# SECTION 1: SPHERICAL SURFACE MESH GENERATION
# ============================================================================

def rotate_vertex(vertex: Tuple[float, float, float], 
                  angle_x: float, 
                  angle_y: float, 
                  angle_z: float) -> Tuple[float, float, float]:
    """
    Rotate a 3D vertex by specified angles around x, y, and z axes.
    
    Parameters
    ----------
    vertex : tuple of float
        The (x, y, z) coordinates of the vertex
    angle_x : float
        Rotation angle around x-axis (radians)
    angle_y : float
        Rotation angle around y-axis (radians)
    angle_z : float
        Rotation angle around z-axis (radians)
    
    Returns
    -------
    tuple of float
        Rotated vertex coordinates
    """
    # Rotation matrix for x-axis
    Rx = [
        [1, 0, 0],
        [0, cos(angle_x), -sin(angle_x)],
        [0, sin(angle_x), cos(angle_x)]
    ]

    # Rotation matrix for y-axis
    Ry = [
        [cos(angle_y), 0, sin(angle_y)],
        [0, 1, 0],
        [-sin(angle_y), 0, cos(angle_y)]
    ]

    # Rotation matrix for z-axis
    Rz = [
        [cos(angle_z), -sin(angle_z), 0],
        [sin(angle_z), cos(angle_z), 0],
        [0, 0, 1]
    ]

    # Combine rotations by matrix multiplication (R = Rz * Ry * Rx)
    R_combined = [[sum(Rz[i][k] * Ry[k][j] for k in range(3)) for j in range(3)] for i in range(3)]
    R_final = [[sum(R_combined[i][k] * Rx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]

    # Apply the combined rotation
    return tuple(
        sum(vertex[j] * R_final[i][j] for j in range(3))
        for i in range(3)
    )


def create_icosphere(radius: float, refinement: int) -> Tuple[List[Tuple], Dict]:
    """
    Create an icosphere mesh using recursive refinement of an icosahedron.
    
    The icosphere is generated by:
    1. Starting with a regular icosahedron
    2. Recursively subdividing each triangle
    3. Projecting new vertices onto the sphere surface
    
    Refinement levels correspond to element counts:
    - Level 0: 20 elements
    - Level 1: 80 elements
    - Level 2: 320 elements
    - Level 3: 1280 elements
    - Level 4: 5120 elements
    
    Parameters
    ----------
    radius : float
        Radius of the sphere
    refinement : int
        Number of refinement iterations (0-5 recommended)
    
    Returns
    -------
    vertices : list of tuple
        List of (x, y, z) coordinates for each vertex
    midpoint_indices : dict
        Dictionary mapping face tuples to their midpoint indices
    """
    # Golden ratio
    PHI = (1 + sqrt(5)) / 2.

    # Vertices of a regular icosahedron
    vertices = [
        (-1, PHI, 0), (1, PHI, 0), (-1, -PHI, 0), (1, -PHI, 0),
        (0, -1, PHI), (0, 1, PHI), (0, -1, -PHI), (0, 1, -PHI),
        (PHI, 0, -1), (PHI, 0, 1), (-PHI, 0, -1), (-PHI, 0, 1),
    ]

    # Scale and rotate vertices to align properly (these values can be changed)
    angle_y = 121.719 * pi / 180.  # Rotation angle around the y-axis
    angle_x = 0.  # Rotation angle around the x-axis
    vertices = [rotate_vertex((radius * x / sqrt(x**2 + y**2 + z**2),
                               radius * y / sqrt(x**2 + y**2 + z**2),
                               radius * z / sqrt(x**2 + y**2 + z**2)), angle_x, angle_y, 0.)
                for x, y, z in vertices]

    # Faces of the icosahedron (20 triangular faces)
    faces = [
        (0, 11, 5), (0, 5, 1), (0, 1, 7), (0, 7, 10), (0, 10, 11),
        (1, 5, 9), (5, 11, 4), (11, 10, 2), (10, 7, 6), (7, 1, 8),
        (3, 9, 4), (3, 4, 2), (3, 2, 6), (3, 6, 8), (3, 8, 9),
        (4, 9, 5), (2, 4, 11), (6, 2, 10), (8, 6, 7), (9, 8, 1),
    ]

    # Refine triangles by subdividing and projecting onto sphere
    midpoint_map = {}
    
    def get_midpoint_index(v1, v2):
        """Get or create midpoint between two vertices."""
        if (v1, v2) in midpoint_map:
            return midpoint_map[(v1, v2)]
        elif (v2, v1) in midpoint_map:
            return midpoint_map[(v2, v1)]
        else:
            mid = tuple((vertices[v1][i] + vertices[v2][i]) / 2 for i in range(3))
            # Project midpoint onto the sphere
            mid = tuple(radius * x / sqrt(mid[0]**2 + mid[1]**2 + mid[2]**2) for x in mid)
            vertices.append(mid)
            midpoint_index = len(vertices) - 1
            midpoint_map[(v1, v2)] = midpoint_index
            return midpoint_index

    for iteration in range(refinement):
        faces_new = []
        for i1, i2, i3 in faces:
            # Get midpoints of each edge
            a = get_midpoint_index(i1, i2)
            b = get_midpoint_index(i2, i3)
            c = get_midpoint_index(i3, i1)
            # Create 4 new triangles from the original triangle
            faces_new.extend([(i1, a, c), (i2, b, a), (i3, c, b), (a, b, c)])
        faces = faces_new
        print(f"Refinement level {iteration + 1} complete: {len(faces)} triangles")

    # Normalize vertices to ensure they lie exactly on the sphere surface
    vertices = [(radius * x / sqrt(x**2 + y**2 + z**2), 
                 radius * y / sqrt(x**2 + y**2 + z**2), 
                 radius * z / sqrt(x**2 + y**2 + z**2)) 
                for x, y, z in vertices]

    # Create a dictionary for Q2 triangle connectivity (6 nodes per triangle)
    midpoint_indices = {}
    for face in faces:
        v1, v2, v3 = face
        mid1 = get_midpoint_index(v1, v2)
        mid2 = get_midpoint_index(v2, v3)
        mid3 = get_midpoint_index(v3, v1)
        midpoint_indices[face] = (mid1, mid2, mid3)

    return vertices, midpoint_indices


# ============================================================================
# SECTION 2: RADIAL EXTRUSION
# ============================================================================

def calculate_layer_heights(num_layers: int, 
                            total_height: float, 
                            distribution: str,
                            growth_ratio: float = 1.0,
                            manual_heights: List[float] = None) -> List[float]:
    """
    Calculate the height of each layer based on the specified distribution.
    
    Parameters
    ----------
    num_layers : int
        Number of layers to extrude
    total_height : float
        Total radial distance to extrude (R - r)
    distribution : str
        Distribution type: 'equidistant', 'geometric', or 'manual'
    growth_ratio : float, optional
        Growth ratio for geometric progression (default: 1.0)
    manual_heights : list of float, optional
        Manual specification of layer heights
    
    Returns
    -------
    list of float
        Height of each layer
    """
    if distribution == 'manual':
        if manual_heights is None:
            raise ValueError("Manual heights must be provided for manual distribution")
        if len(manual_heights) != num_layers:
            raise ValueError(f"Manual heights list length ({len(manual_heights)}) "
                           f"must match num_layers ({num_layers})")
        if abs(sum(manual_heights) - total_height) > 1e-6:
            print(f"Warning: Sum of manual heights ({sum(manual_heights)}) "
                  f"differs from total_height ({total_height})")
        return manual_heights
    
    elif distribution == 'equidistant':
        layer_height = total_height / num_layers
        return [layer_height] * num_layers
    
    elif distribution == 'geometric':
        if growth_ratio == 1.0:
            # Degenerate case: same as equidistant
            return [total_height / num_layers] * num_layers
        else:
            # Geometric progression: h_i = h_0 * r^i
            # Sum = h_0 * (r^n - 1) / (r - 1) = total_height
            initial_height = total_height * (growth_ratio - 1) / (growth_ratio**num_layers - 1)
            layer_heights = [initial_height * (growth_ratio ** i) for i in range(num_layers)]
            return layer_heights
    
    else:
        raise ValueError(f"Unknown distribution type: {distribution}")


def extrude_triangles(nodes: Dict[int, List[float]], 
                     triangles: Dict[int, List[int]], 
                     layer_heights: List[float]) -> Tuple[Dict, Dict, Dict]:
    """
    Extrude Q2 triangular surface mesh radially to create Q2 prismatic elements.
    
    Each Q2 triangle (6 nodes) is extruded to form an 18-node prism.
    The extrusion is performed in the radial direction (outward normal).
    
    Parameters
    ----------
    nodes : dict
        Dictionary mapping node IDs to [x, y, z] coordinates
    triangles : dict
        Dictionary mapping triangle IDs to lists of 6 node IDs
    layer_heights : list of float
        Height of each layer
    
    Returns
    -------
    global_nodes : dict
        All nodes including original and extruded nodes
    prisms : dict
        Dictionary mapping prism IDs to lists of 18 node IDs
    outlet_triangles : dict
        Top surface triangles (outlet boundary)
    """
    num_layers = len(layer_heights)
    
    global_nodes = nodes.copy()  # Tracks all nodes across all layers
    prisms = {}
    outlet_triangles = {}
    triangle_top_nodes = {}  # To store top nodes for each triangle and layer
    next_node_id = max(nodes.keys()) + 1
    next_elem_id = max(triangles.keys()) + 1

    print(f"\nStarting radial extrusion: {num_layers} layers")
    print(f"Layer heights: {[f'{h:.6f}' for h in layer_heights[:5]]}{'...' if num_layers > 5 else ''}")

    for layer, layer_height in enumerate(layer_heights):
        layer_nodes = {}  # Dictionary to track nodes added in the current layer
        
        for triangle_id, triangle_nodes in triangles.items():
            # Get base triangle node coordinates
            if layer == 0:
                base_nodes_coords = [global_nodes[node_id] for node_id in triangle_nodes]
            else:
                triangle_nodes = triangle_top_nodes[triangle_id]
                base_nodes_coords = [global_nodes[node_id] for node_id in triangle_nodes]

            # Compute radial normals for each node (direction: outward from origin)
            normals = []
            for coord in base_nodes_coords:
                norm = math.sqrt(coord[0]**2 + coord[1]**2 + coord[2]**2)
                normal = [coord[0]/norm, coord[1]/norm, coord[2]/norm]
                normals.append(normal)
            
            # Create top and mid-layer nodes for this triangle
            top_node_ids = []
            mid_node_ids = []
            
            for idx, (coord, normal) in enumerate(zip(base_nodes_coords, normals)):
                # Top node (full layer height)
                top_coord = [coord[i] + normal[i] * layer_height for i in range(3)]
                # Mid node (half layer height for Q2 element)
                mid_coord = [coord[i] + normal[i] * (layer_height / 2) for i in range(3)]

                # Check and add/reuse the top_coord node
                coord_key = str(top_coord)
                if coord_key not in layer_nodes:
                    global_nodes[next_node_id] = top_coord
                    layer_nodes[coord_key] = next_node_id
                    top_node_ids.append(next_node_id)
                    next_node_id += 1
                else:
                    top_node_ids.append(layer_nodes[coord_key])
                
                # Check and add/reuse the mid_coord node
                coord_key = str(mid_coord)
                if coord_key not in layer_nodes:
                    global_nodes[next_node_id] = mid_coord
                    layer_nodes[coord_key] = next_node_id
                    mid_node_ids.append(next_node_id)
                    next_node_id += 1
                else:
                    mid_node_ids.append(layer_nodes[coord_key])

            # Construct the 18-node Q2 prism element
            # Node ordering for CFmesh format
            prism_nodes = (
                triangle_nodes[:3] +      # Bottom corner nodes (3)
                top_node_ids[:3] +        # Top corner nodes (3)
                triangle_nodes[3:] +      # Bottom edge mid-nodes (3)
                [mid_node_ids[0], mid_node_ids[3], mid_node_ids[1]] +  # Vertical edge mid-nodes (3)
                [mid_node_ids[4], mid_node_ids[2], mid_node_ids[5]] +  # Vertical edge mid-nodes (3)
                top_node_ids[3:]          # Top edge mid-nodes (3)
            )
            
            prisms[next_elem_id] = prism_nodes
            next_elem_id += 1

            # Store the top triangle nodes for the next layer
            triangle_top_nodes[triangle_id] = top_node_ids

            # Save the top triangle nodes for the outlet boundary
            if layer == num_layers - 1:
                outlet_triangles[triangle_id] = top_node_ids
        
        # Clear layer_nodes for the next layer to save memory
        layer_nodes.clear()
        print(f"Layer {layer + 1}/{num_layers} completed")
    
    print(f"Extrusion complete: {len(prisms)} prisms, {len(global_nodes)} nodes")
    return global_nodes, prisms, outlet_triangles


# ============================================================================
# SECTION 3: FILE I/O
# ============================================================================

def write_CFmesh(filename: str, 
                 nodes: Dict, 
                 prisms: Dict, 
                 inlet: Dict, 
                 outlet: Dict):
    """
    Write mesh to CFmesh format (COOLFluiD mesh format).
    
    Parameters
    ----------
    filename : str
        Output filename
    nodes : dict
        Node dictionary
    prisms : dict
        Prism element dictionary
    inlet : dict
        Inlet boundary triangles
    outlet : dict
        Outlet boundary triangles
    """
    with open(filename, 'w') as f:
        # Write header
        f.write("!COOLFLUID_VERSION 2013.9\n")
        f.write("!CFMESH_FORMAT_VERSION 1.3\n")
        f.write("!NB_DIM 3\n")
        f.write("!NB_EQ 1\n")
        f.write(f"!NB_NODES {len(nodes)} 0\n")
        f.write(f"!NB_STATES {len(prisms)} 0\n")
        f.write(f"!NB_ELEM {len(prisms)}\n")
        f.write("!NB_ELEM_TYPES 1\n")
        f.write("!GEOM_POLYORDER 2\n")
        f.write("!SOL_POLYORDER 0\n")
        f.write("!ELEM_TYPES Prism\n")
        f.write(f"!NB_ELEM_PER_TYPE {len(prisms)}\n")
        f.write("!NB_NODES_PER_TYPE 18\n")
        f.write("!NB_STATES_PER_TYPE 1\n")
        f.write("!LIST_ELEM\n")
        
        # Write prisms with state ID at the end
        state_id = 0
        for prism_nodes in prisms.values():
            # CFmesh uses 0-based indexing
            corrected_nodes = [node - 1 for node in prism_nodes]
            f.write(" ".join(map(str, corrected_nodes)) + f" {state_id}\n")
            state_id += 1

        # Write boundary conditions (TRSs)
        f.write("!NB_TRSs 2\n")
        
        # Inlet section
        f.write("!TRS_NAME Inlet\n")
        f.write("!NB_TRs 1\n")
        f.write(f"!NB_GEOM_ENTS {len(inlet)}\n")
        f.write("!GEOM_TYPE Face\n")
        f.write("!LIST_GEOM_ENT\n")
        for triangle_nodes in inlet.values():
            corrected_nodes = [node - 1 for node in triangle_nodes]
            f.write("6 0 " + " ".join(map(str, corrected_nodes)) + "\n")
        
        # Outlet section
        f.write("!TRS_NAME Outlet\n")
        f.write("!NB_TRs 1\n")
        f.write(f"!NB_GEOM_ENTS {len(outlet)}\n")
        f.write("!GEOM_TYPE Face\n")
        f.write("!LIST_GEOM_ENT\n")
        for triangle_nodes in outlet.values():
            corrected_nodes = [node - 1 for node in triangle_nodes]
            f.write("6 0 " + " ".join(map(str, corrected_nodes)) + "\n")

        # List of nodes
        f.write("!LIST_NODE\n")
        for _, coords in nodes.items():
            f.write("{} {} {}\n".format(coords[0], coords[1], coords[2]))
        
        # List state
        f.write("!LIST_STATE 0\n")
        f.write("!END\n")

    print(f"CFmesh file written: {filename}")


def write_msh(filename: str, 
              nodes: Dict, 
              prisms: Dict, 
              inlet: Dict, 
              outlet: Dict):
    """
    Write mesh to Gmsh MSH format (version 2.2).
    
    Parameters
    ----------
    filename : str
        Output filename
    nodes : dict
        Node dictionary
    prisms : dict
        Prism element dictionary
    inlet : dict
        Inlet boundary triangles
    outlet : dict
        Outlet boundary triangles
    """
    with open(filename, 'w') as file:
        # Write MSH file header
        file.write("$MeshFormat\n2.2 0 8\n$EndMeshFormat\n")
        
        # Write physical names (boundary and volume tags)
        file.write("$PhysicalNames\n")
        file.write("3\n")
        file.write("2 1 \"Inlet\"\n")
        file.write("2 2 \"Outlet\"\n")
        file.write("3 3 \"InnerCells\"\n")
        file.write("$EndPhysicalNames\n")
        
        # Write nodes
        file.write("$Nodes\n")
        file.write(str(len(nodes)) + "\n")
        for node_id, coords in nodes.items():
            file.write("{} {} {} {}\n".format(node_id, coords[0], coords[1], coords[2]))
        file.write("$EndNodes\n")
        
        # Write elements
        file.write("$Elements\n")
        total_elems = len(prisms) + len(inlet) + len(outlet)
        file.write(str(total_elems) + "\n")

        elem_id = 0

        # Inlet triangles (Gmsh type 9: 6-node triangle)
        for triangle_nodes in inlet.values():
            elem_id += 1
            file.write(" ".join(map(str, [elem_id, 9, 2, 1, 1] + triangle_nodes)) + "\n")
        
        # Outlet triangles
        for triangle_nodes in outlet.values():
            elem_id += 1
            file.write(" ".join(map(str, [elem_id, 9, 2, 2, 2] + triangle_nodes)) + "\n")
            
        # Prisms (Gmsh type 13: 18-node prism)
        # Note: Node ordering differs between MSH and CFmesh formats
        for prism_nodes in prisms.values():
            elem_id += 1
            # Reorder nodes for MSH format
            msh_prism_nodes = [
                prism_nodes[0], prism_nodes[1], prism_nodes[2],  # Bottom corners
                prism_nodes[3], prism_nodes[4], prism_nodes[5],  # Top corners
                prism_nodes[6], prism_nodes[8], prism_nodes[9],  # Bottom edge mids (reordered)
                prism_nodes[7], prism_nodes[10], prism_nodes[11], # Mid-height edge mids (reordered)
                prism_nodes[12], prism_nodes[14], prism_nodes[13], # Top edge mids (reordered)
                prism_nodes[15], prism_nodes[17], prism_nodes[16]  # Additional mids (reordered)
            ]
            file.write(" ".join(map(str, [elem_id, 13, 2, 3, 3] + msh_prism_nodes)) + "\n")

        file.write("$EndElements\n")

    print(f"MSH file written: {filename}")


# ============================================================================
# SECTION 4: MAIN EXECUTION
# ============================================================================

def generate_spherical_shell_mesh(inner_radius: float,
                                  outer_radius: float,
                                  refinement_level: int,
                                  num_layers: int = None,
                                  distribution: str = 'geometric',
                                  growth_ratio: float = 1.0,
                                  manual_heights: List[float] = None,
                                  output_format: str = 'cfmesh',
                                  output_filename: str = None):
    """
    Generate a complete spherical shell mesh.
    
    Parameters
    ----------
    inner_radius : float
        Inner sphere radius
    outer_radius : float
        Outer sphere radius
    refinement_level : int
        Refinement level for inner sphere (0-5)
    num_layers : int, optional
        Number of layers (required unless using manual heights)
    distribution : str
        Layer distribution: 'equidistant', 'geometric', or 'manual'
    growth_ratio : float
        Growth ratio for geometric distribution
    manual_heights : list of float, optional
        Manual layer heights
    output_format : str
        Output format: 'cfmesh', 'msh', or 'both'
    output_filename : str, optional
        Output filename (without extension)
    """
    # Validate inputs
    if inner_radius >= outer_radius:
        raise ValueError("Inner radius must be less than outer radius")
    
    if distribution == 'manual':
        if manual_heights is None:
            raise ValueError("Manual heights required for manual distribution")
        num_layers = len(manual_heights)
    else:
        if num_layers is None:
            raise ValueError("Number of layers required for non-manual distribution")
    
    total_height = outer_radius - inner_radius
    
    # Generate output filename if not provided
    if output_filename is None:
        output_filename = f"{num_layers}x{4**(refinement_level+1)*20}-r{inner_radius}"
    
    print("=" * 70)
    print("SPHERICAL SHELL MESH GENERATOR")
    print("=" * 70)
    print(f"Inner radius: {inner_radius}")
    print(f"Outer radius: {outer_radius}")
    print(f"Shell thickness: {total_height}")
    print(f"Refinement level: {refinement_level}")
    print(f"Number of layers: {num_layers}")
    print(f"Distribution: {distribution}")
    if distribution == 'geometric':
        print(f"Growth ratio: {growth_ratio}")
    print("=" * 70)
    
    # Step 1: Generate inner sphere surface mesh
    print("\n[1/4] Generating inner sphere surface...")
    vertices, midpoint_indices = create_icosphere(inner_radius, refinement_level)
    
    # Convert to node and triangle dictionaries
    nodes = {i+1: list(v) for i, v in enumerate(vertices)}
    triangles = {}
    tri_id = 1
    for (v1, v2, v3), (m1, m2, m3) in midpoint_indices.items():
        triangles[tri_id] = [v1+1, v2+1, v3+1, m1+1, m2+1, m3+1]
        tri_id += 1
    
    print(f"Inner sphere mesh: {len(nodes)} nodes, {len(triangles)} triangles")
    
    # Step 2: Calculate layer heights
    print("\n[2/4] Calculating layer heights...")
    layer_heights = calculate_layer_heights(num_layers, total_height, 
                                            distribution, growth_ratio, manual_heights)
    
    # Step 3: Extrude to create 3D mesh
    print("\n[3/4] Extruding mesh radially...")
    all_nodes, prisms, outlet_triangles = extrude_triangles(nodes, triangles, layer_heights)
    
    # Step 4: Write output files
    print("\n[4/4] Writing output files...")
    if output_format in ['cfmesh', 'both']:
        cfmesh_file = output_filename if output_filename.endswith('.CFmesh') else f"{output_filename}.CFmesh"
        write_CFmesh(cfmesh_file, all_nodes, prisms, triangles, outlet_triangles)
    
    if output_format in ['msh', 'both']:
        msh_file = output_filename if output_filename.endswith('.msh') else f"{output_filename}.msh"
        write_msh(msh_file, all_nodes, prisms, triangles, outlet_triangles)
    
    print("\n" + "=" * 70)
    print("MESH GENERATION COMPLETE")
    print("=" * 70)


def main():
    """Command-line interface for mesh generation."""
    parser = argparse.ArgumentParser(
        description='Generate spherical shell mesh with prismatic Q2 elements',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Geometric progression with 20 layers
  python generate_spherical_shell_Q2.py -r 21.5 -R 235 -l 3 -n 20 -d geometric -k 1.2
  
  # Equidistant layers
  python generate_spherical_shell_Q2.py -r 21.5 -R 235 -l 3 -n 30 -d equidistant
  
  # Manual layer heights
  python generate_spherical_shell_Q2.py -r 1.0 -R 2.0 -l 2 -d manual -m 0.3 0.4 0.3
  
  # Output both CFmesh and MSH formats
  python generate_spherical_shell_Q2.py -r 21.5 -R 235 -l 3 -n 20 -k 1.2 -f both
        """
    )
    
    # Required arguments
    parser.add_argument('-r', '--inner-radius', type=float, required=True,
                        help='Inner sphere radius')
    parser.add_argument('-R', '--outer-radius', type=float, required=True,
                        help='Outer sphere radius')
    parser.add_argument('-l', '--refinement-level', type=int, required=True,
                        help='Refinement level for inner sphere (0-5)')
    
    # Layer distribution arguments
    parser.add_argument('-n', '--num-layers', type=int,
                        help='Number of layers (required for equidistant/geometric)')
    parser.add_argument('-d', '--distribution', type=str, 
                        default='geometric',
                        choices=['equidistant', 'geometric', 'manual'],
                        help='Layer height distribution method (default: geometric)')
    parser.add_argument('-k', '--growth-ratio', type=float, default=1.0,
                        help='Growth ratio for geometric distribution (default: 1.0)')
    parser.add_argument('-m', '--manual-heights', type=float, nargs='+',
                        help='Manual layer heights (space-separated)')
    
    # Output arguments
    parser.add_argument('-f', '--format', type=str, default='cfmesh',
                        choices=['cfmesh', 'msh', 'both'],
                        help='Output format (default: cfmesh)')
    parser.add_argument('-o', '--output', type=str,
                        help='Output filename (without extension)')
    
    args = parser.parse_args()
    
    # Generate mesh
    generate_spherical_shell_mesh(
        inner_radius=args.inner_radius,
        outer_radius=args.outer_radius,
        refinement_level=args.refinement_level,
        num_layers=args.num_layers,
        distribution=args.distribution,
        growth_ratio=args.growth_ratio,
        manual_heights=args.manual_heights,
        output_format=args.format,
        output_filename=args.output
    )


if __name__ == '__main__':
    main()
