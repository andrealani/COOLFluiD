"""
Spherical Shell Q2 Mesh Generator

This script generates a 3D mesh of a spherical shell using:
1. Geodesic polyhedron refinement for the inner surface (with Q2 triangles)
2. Radial extrusion to create prismatic Q2 elements

Author: Rayan Dhib
Date: October 2025
"""

import math
from numpy import pi, cos, sin, sqrt, arctan2, arcsin
import numpy as np
import argparse
from typing import Dict, List, Tuple


# ============================================================================
# SECTION 1: SPHERICAL SURFACE MESH GENERATION
# ============================================================================

def rotate_vertex(vertex: Tuple[float, float, float], 
                  angle_x: float, 
                  angle_y: float, 
                  angle_z: float) -> Tuple[float, float, float]:
    """
    Rotate a 3D vertex by specified angles around x, y, and z axes.
    
    Parameters
    ----------
    vertex : tuple of float
        The (x, y, z) coordinates of the vertex
    angle_x : float
        Rotation angle around x-axis (radians)
    angle_y : float
        Rotation angle around y-axis (radians)
    angle_z : float
        Rotation angle around z-axis (radians)
    
    Returns
    -------
    tuple of float
        Rotated vertex coordinates
    """
    # Rotation matrix for x-axis
    Rx = [
        [1, 0, 0],
        [0, cos(angle_x), -sin(angle_x)],
        [0, sin(angle_x), cos(angle_x)]
    ]

    # Rotation matrix for y-axis
    Ry = [
        [cos(angle_y), 0, sin(angle_y)],
        [0, 1, 0],
        [-sin(angle_y), 0, cos(angle_y)]
    ]

    # Rotation matrix for z-axis
    Rz = [
        [cos(angle_z), -sin(angle_z), 0],
        [sin(angle_z), cos(angle_z), 0],
        [0, 0, 1]
    ]

    # Combine rotations by matrix multiplication (R = Rz * Ry * Rx)
    R_combined = [[sum(Rz[i][k] * Ry[k][j] for k in range(3)) for j in range(3)] for i in range(3)]
    R_final = [[sum(R_combined[i][k] * Rx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]

    # Apply the combined rotation
    return tuple(
        sum(vertex[j] * R_final[i][j] for j in range(3))
        for i in range(3)
    )


def create_icosphere(radius: float, refinement: int) -> Tuple[List[Tuple], Dict]:
    """
    Create an icosphere mesh using recursive refinement of an icosahedron.
    
    The icosphere is generated by:
    1. Starting with a regular icosahedron
    2. Recursively subdividing each triangle
    3. Projecting new vertices onto the sphere surface
    
    Refinement levels correspond to element counts:
    - Level 0: 20 elements
    - Level 1: 80 elements
    - Level 2: 320 elements
    - Level 3: 1280 elements
    - Level 4: 5120 elements
    
    Parameters
    ----------
    radius : float
        Radius of the sphere
    refinement : int
        Number of refinement iterations (0-5 recommended)
    
    Returns
    -------
    vertices : list of tuple
        List of (x, y, z) coordinates for each vertex
    midpoint_indices : dict
        Dictionary mapping face tuples to their midpoint indices
    """
    # Golden ratio
    PHI = (1 + sqrt(5)) / 2.

    # Vertices of a regular icosahedron
    vertices = [
        (-1, PHI, 0), (1, PHI, 0), (-1, -PHI, 0), (1, -PHI, 0),
        (0, -1, PHI), (0, 1, PHI), (0, -1, -PHI), (0, 1, -PHI),
        (PHI, 0, -1), (PHI, 0, 1), (-PHI, 0, -1), (-PHI, 0, 1),
    ]

    # Scale and rotate vertices to align properly (these values can be changed)
    angle_y = 121.719 * pi / 180.  # Rotation angle around the y-axis
    angle_x = 0.  # Rotation angle around the x-axis
    vertices = [rotate_vertex((radius * x / sqrt(x**2 + y**2 + z**2),
                               radius * y / sqrt(x**2 + y**2 + z**2),
                               radius * z / sqrt(x**2 + y**2 + z**2)), angle_x, angle_y, 0.)
                for x, y, z in vertices]

    # Faces of the icosahedron (20 triangular faces)
    faces = [
        (0, 11, 5), (0, 5, 1), (0, 1, 7), (0, 7, 10), (0, 10, 11),
        (1, 5, 9), (5, 11, 4), (11, 10, 2), (10, 7, 6), (7, 1, 8),
        (3, 9, 4), (3, 4, 2), (3, 2, 6), (3, 6, 8), (3, 8, 9),
        (4, 9, 5), (2, 4, 11), (6, 2, 10), (8, 6, 7), (9, 8, 1),
    ]

    # Refine triangles by subdividing and projecting onto sphere
    midpoint_map = {}
    
    def get_midpoint_index(v1, v2):
        """Get or create midpoint between two vertices."""
        if (v1, v2) in midpoint_map:
            return midpoint_map[(v1, v2)]
        elif (v2, v1) in midpoint_map:
            return midpoint_map[(v2, v1)]
        else:
            mid = tuple((vertices[v1][i] + vertices[v2][i]) / 2 for i in range(3))
            # Project midpoint onto the sphere
            mid = tuple(radius * x / sqrt(mid[0]**2 + mid[1]**2 + mid[2]**2) for x in mid)
            vertices.append(mid)
            midpoint_index = len(vertices) - 1
            midpoint_map[(v1, v2)] = midpoint_index
            return midpoint_index

    for iteration in range(refinement):
        faces_new = []
        for i1, i2, i3 in faces:
            # Get midpoints of each edge
            a = get_midpoint_index(i1, i2)
            b = get_midpoint_index(i2, i3)
            c = get_midpoint_index(i3, i1)
            # Create 4 new triangles from the original triangle
            faces_new.extend([(i1, a, c), (i2, b, a), (i3, c, b), (a, b, c)])
        faces = faces_new
        print(f"Refinement level {iteration + 1} complete: {len(faces)} triangles")

    # Normalize vertices to ensure they lie exactly on the sphere surface
    vertices = [(radius * x / sqrt(x**2 + y**2 + z**2), 
                 radius * y / sqrt(x**2 + y**2 + z**2), 
                 radius * z / sqrt(x**2 + y**2 + z**2)) 
                for x, y, z in vertices]

    # Create a dictionary for Q2 triangle connectivity (6 nodes per triangle)
    midpoint_indices = {}
    for face in faces:
        v1, v2, v3 = face
        mid1 = get_midpoint_index(v1, v2)
        mid2 = get_midpoint_index(v2, v3)
        mid3 = get_midpoint_index(v3, v1)
        midpoint_indices[face] = (mid1, mid2, mid3)

    return vertices, midpoint_indices


def create_fibonacci_sphere(radius: float, num_points: int) -> Tuple[List[Tuple], Dict]:
    """
    Create a sphere mesh using Fibonacci spiral point distribution and Delaunay triangulation.
        
    The mesh is generated by:
    1. Distributing points uniformly on sphere using Fibonacci spiral (golden angle)
    2. Computing convex hull in 3D (equivalent to Delaunay on sphere)
    3. Creating Q2 elements by adding edge midpoints projected onto sphere
    
    Parameters
    ----------
    radius : float
        Radius of the sphere
    num_points : int
        Number of vertices on the sphere (triangles ≈ 2 * num_points - 4)
    
    Returns
    -------
    vertices : list of tuple
        List of (x, y, z) coordinates for each vertex
    midpoint_indices : dict
        Dictionary mapping face tuples to their midpoint indices
    
    Notes
    -----
    For N points, you get approximately 2N - 4 triangles (Euler's formula for convex polyhedra).
    Examples:
        - 50 points → ~96 triangles
        - 100 points → ~196 triangles
        - 200 points → ~396 triangles
        - 500 points → ~996 triangles
        - 1000 points → ~1996 triangles
    """
    from scipy.spatial import ConvexHull
    
    # Golden angle in radians
    golden_angle = pi * (3.0 - sqrt(5.0))
    
    # Generate Fibonacci sphere points
    vertices = []
    for i in range(num_points):
        # y goes from 1 to -1 (top to bottom)
        y = 1 - (i / float(num_points - 1)) * 2 if num_points > 1 else 0
        # Radius at this y level
        r_at_y = sqrt(1 - y * y)
        # Golden angle increment
        theta = golden_angle * i
        
        x = cos(theta) * r_at_y
        z = sin(theta) * r_at_y
        
        # Scale to desired radius
        vertices.append((radius * x, radius * y, radius * z))
    
    print(f"Generated {num_points} Fibonacci spiral points on sphere")
    
    # Convert to numpy array for ConvexHull
    points_array = np.array(vertices)
    
    # Compute convex hull (equivalent to Delaunay triangulation on sphere)
    hull = ConvexHull(points_array)
    faces = [tuple(face) for face in hull.simplices]
    
    print(f"Delaunay triangulation complete: {len(faces)} triangles")
    
    # Ensure consistent face orientation (outward normals)
    oriented_faces = []
    for face in faces:
        v0, v1, v2 = [vertices[i] for i in face]
        # Compute face center
        center = [(v0[j] + v1[j] + v2[j]) / 3 for j in range(3)]
        # Compute cross product (v1-v0) x (v2-v0)
        e1 = [v1[j] - v0[j] for j in range(3)]
        e2 = [v2[j] - v0[j] for j in range(3)]
        normal = [
            e1[1]*e2[2] - e1[2]*e2[1],
            e1[2]*e2[0] - e1[0]*e2[2],
            e1[0]*e2[1] - e1[1]*e2[0]
        ]
        # Dot product with center (should be positive for outward normal)
        dot = sum(normal[j] * center[j] for j in range(3))
        if dot < 0:
            # Flip orientation
            oriented_faces.append((face[0], face[2], face[1]))
        else:
            oriented_faces.append(face)
    
    faces = oriented_faces
    
    # Create midpoint map for Q2 elements
    midpoint_map = {}
    vertices = list(vertices)  # Convert to mutable list
    
    def get_midpoint_index(v1, v2):
        """Get or create midpoint between two vertices, projected onto sphere."""
        if (v1, v2) in midpoint_map:
            return midpoint_map[(v1, v2)]
        elif (v2, v1) in midpoint_map:
            return midpoint_map[(v2, v1)]
        else:
            mid = tuple((vertices[v1][i] + vertices[v2][i]) / 2 for i in range(3))
            # Project midpoint onto the sphere
            norm = sqrt(mid[0]**2 + mid[1]**2 + mid[2]**2)
            mid = tuple(radius * x / norm for x in mid)
            vertices.append(mid)
            midpoint_index = len(vertices) - 1
            midpoint_map[(v1, v2)] = midpoint_index
            return midpoint_index
    
    # Create dictionary for Q2 triangle connectivity (6 nodes per triangle)
    midpoint_indices = {}
    for face in faces:
        v1, v2, v3 = face
        mid1 = get_midpoint_index(v1, v2)
        mid2 = get_midpoint_index(v2, v3)
        mid3 = get_midpoint_index(v3, v1)
        midpoint_indices[face] = (mid1, mid2, mid3)
    
    print(f"Q2 upgrade complete: {len(vertices)} total nodes (including edge midpoints)")
    
    return vertices, midpoint_indices


# ============================================================================
# SECTION 2: RADIAL EXTRUSION
# ============================================================================

def calculate_layer_heights(num_layers: int, 
                            total_height: float, 
                            distribution: str,
                            growth_ratio: float = 1.0,
                            manual_heights: List[float] = None,
                            bump_ratio: float = None) -> List[float]:
    """
    Calculate the height of each layer based on the specified distribution.
    
    Parameters
    ----------
    num_layers : int
        Number of layers to extrude
    total_height : float
        Total radial distance to extrude (R - r)
    distribution : str
        Distribution type: 'equidistant', 'geometric', 'bump', or 'manual'
    growth_ratio : float, optional
        Growth ratio for geometric progression (default: 1.0)
    manual_heights : list of float, optional
        Manual specification of layer heights
    bump_ratio : float, optional
        Ratio of smallest to largest layer for bump distribution (0 < bump_ratio < 1)
        Smaller values = more refinement at boundaries
    
    Returns
    -------
    list of float
        Height of each layer
    """
    if distribution == 'manual':
        if manual_heights is None:
            raise ValueError("Manual heights must be provided for manual distribution")
        if len(manual_heights) != num_layers:
            raise ValueError(f"Manual heights list length ({len(manual_heights)}) "
                           f"must match num_layers ({num_layers})")
        if abs(sum(manual_heights) - total_height) > 1e-6:
            print(f"Warning: Sum of manual heights ({sum(manual_heights)}) "
                  f"differs from total_height ({total_height})")
        return manual_heights
    
    elif distribution == 'equidistant':
        layer_height = total_height / num_layers
        return [layer_height] * num_layers
    
    elif distribution == 'geometric':
        if growth_ratio == 1.0:
            # Degenerate case: same as equidistant
            return [total_height / num_layers] * num_layers
        else:
            # Geometric progression: h_i = h_0 * r^i
            # Sum = h_0 * (r^n - 1) / (r - 1) = total_height
            initial_height = total_height * (growth_ratio - 1) / (growth_ratio**num_layers - 1)
            layer_heights = [initial_height * (growth_ratio ** i) for i in range(num_layers)]
            return layer_heights
    
    elif distribution == 'bump':
        # Bump distribution: refined at both inlet (inner) and outlet (outer)
        # Uses a sine-based distribution that creates smallest layers at boundaries
        # and largest layers in the middle
        if bump_ratio is None:
            bump_ratio = 0.3  # Default: boundary layers are 30% of middle layer size
        
        if not 0 < bump_ratio < 1:
            raise ValueError(f"bump_ratio must be between 0 and 1, got {bump_ratio}")
        
        # Use a cosine distribution to create the bump effect
        # h(i) = a + b * (1 - cos(pi * i / (n-1)))
        # This gives minimum at i=0 and i=n-1 (boundaries), maximum at i=(n-1)/2 (middle)
        
        # For a single layer, just return uniform
        if num_layers == 1:
            return [total_height]
        
        # Calculate weights using cosine distribution
        # w(i) = bump_ratio + (1 - bump_ratio) * sin(pi * (i + 0.5) / n)
        # This creates a smooth bell curve with minimum at boundaries
        weights = []
        for i in range(num_layers):
            # Normalized position from 0 to 1
            t = (i + 0.5) / num_layers
            # Sine distribution: peaks at middle (t=0.5), minimums at boundaries
            w = bump_ratio + (1 - bump_ratio) * sin(pi * t)
            weights.append(w)
        
        # Normalize weights to sum to total_height
        weight_sum = sum(weights)
        layer_heights = [w * total_height / weight_sum for w in weights]
        
        return layer_heights
    
    else:
        raise ValueError(f"Unknown distribution type: {distribution}")


def extrude_triangles(nodes: Dict[int, List[float]], 
                     triangles: Dict[int, List[int]], 
                     layer_heights: List[float]) -> Tuple[Dict, Dict, Dict]:
    """
    Extrude Q2 triangular surface mesh radially to create Q2 prismatic elements.
    
    Each Q2 triangle (6 nodes) is extruded to form an 18-node prism.
    The extrusion is performed in the radial direction (outward normal).
    
    Parameters
    ----------
    nodes : dict
        Dictionary mapping node IDs to [x, y, z] coordinates
    triangles : dict
        Dictionary mapping triangle IDs to lists of 6 node IDs
    layer_heights : list of float
        Height of each layer
    
    Returns
    -------
    global_nodes : dict
        All nodes including original and extruded nodes
    prisms : dict
        Dictionary mapping prism IDs to lists of 18 node IDs
    outlet_triangles : dict
        Top surface triangles (outlet boundary)
    """
    num_layers = len(layer_heights)
    
    global_nodes = nodes.copy()  # Tracks all nodes across all layers
    prisms = {}
    outlet_triangles = {}
    triangle_top_nodes = {}  # To store top nodes for each triangle and layer
    next_node_id = max(nodes.keys()) + 1
    next_elem_id = max(triangles.keys()) + 1

    print(f"\nStarting radial extrusion: {num_layers} layers")
    print(f"Layer heights: {[f'{h:.6f}' for h in layer_heights[:5]]}{'...' if num_layers > 5 else ''}")

    for layer, layer_height in enumerate(layer_heights):
        layer_nodes = {}  # Dictionary to track nodes added in the current layer
        
        for triangle_id, triangle_nodes in triangles.items():
            # Get base triangle node coordinates
            if layer == 0:
                base_nodes_coords = [global_nodes[node_id] for node_id in triangle_nodes]
            else:
                triangle_nodes = triangle_top_nodes[triangle_id]
                base_nodes_coords = [global_nodes[node_id] for node_id in triangle_nodes]

            # Compute radial normals for each node (direction: outward from origin)
            normals = []
            for coord in base_nodes_coords:
                norm = math.sqrt(coord[0]**2 + coord[1]**2 + coord[2]**2)
                normal = [coord[0]/norm, coord[1]/norm, coord[2]/norm]
                normals.append(normal)
            
            # Create top and mid-layer nodes for this triangle
            top_node_ids = []
            mid_node_ids = []
            
            for idx, (coord, normal) in enumerate(zip(base_nodes_coords, normals)):
                # Top node (full layer height)
                top_coord = [coord[i] + normal[i] * layer_height for i in range(3)]
                # Mid node (half layer height for Q2 element)
                mid_coord = [coord[i] + normal[i] * (layer_height / 2) for i in range(3)]

                # Check and add/reuse the top_coord node
                coord_key = str(top_coord)
                if coord_key not in layer_nodes:
                    global_nodes[next_node_id] = top_coord
                    layer_nodes[coord_key] = next_node_id
                    top_node_ids.append(next_node_id)
                    next_node_id += 1
                else:
                    top_node_ids.append(layer_nodes[coord_key])
                
                # Check and add/reuse the mid_coord node
                coord_key = str(mid_coord)
                if coord_key not in layer_nodes:
                    global_nodes[next_node_id] = mid_coord
                    layer_nodes[coord_key] = next_node_id
                    mid_node_ids.append(next_node_id)
                    next_node_id += 1
                else:
                    mid_node_ids.append(layer_nodes[coord_key])

            # Construct the 18-node Q2 prism element
            # Node ordering for CFmesh format
            prism_nodes = (
                triangle_nodes[:3] +      # Bottom corner nodes (3)
                top_node_ids[:3] +        # Top corner nodes (3)
                triangle_nodes[3:] +      # Bottom edge mid-nodes (3)
                [mid_node_ids[0], mid_node_ids[3], mid_node_ids[1]] +  # Vertical edge mid-nodes (3)
                [mid_node_ids[4], mid_node_ids[2], mid_node_ids[5]] +  # Vertical edge mid-nodes (3)
                top_node_ids[3:]          # Top edge mid-nodes (3)
            )
            
            prisms[next_elem_id] = prism_nodes
            next_elem_id += 1

            # Store the top triangle nodes for the next layer
            triangle_top_nodes[triangle_id] = top_node_ids

            # Save the top triangle nodes for the outlet boundary
            if layer == num_layers - 1:
                outlet_triangles[triangle_id] = top_node_ids
        
        # Clear layer_nodes for the next layer to save memory
        layer_nodes.clear()
        print(f"Layer {layer + 1}/{num_layers} completed")
    
    print(f"Extrusion complete: {len(prisms)} prisms, {len(global_nodes)} nodes")
    return global_nodes, prisms, outlet_triangles


# ============================================================================
# SECTION 3: FILE I/O
# ============================================================================

def write_CFmesh(filename: str, 
                 nodes: Dict, 
                 prisms: Dict, 
                 inlet: Dict, 
                 outlet: Dict):
    """
    Write mesh to CFmesh format (COOLFluiD mesh format).
    
    Parameters
    ----------
    filename : str
        Output filename
    nodes : dict
        Node dictionary
    prisms : dict
        Prism element dictionary
    inlet : dict
        Inlet boundary triangles
    outlet : dict
        Outlet boundary triangles
    """
    with open(filename, 'w') as f:
        # Write header
        f.write("!COOLFLUID_VERSION 2013.9\n")
        f.write("!CFMESH_FORMAT_VERSION 1.3\n")
        f.write("!NB_DIM 3\n")
        f.write("!NB_EQ 1\n")
        f.write(f"!NB_NODES {len(nodes)} 0\n")
        f.write(f"!NB_STATES {len(prisms)} 0\n")
        f.write(f"!NB_ELEM {len(prisms)}\n")
        f.write("!NB_ELEM_TYPES 1\n")
        f.write("!GEOM_POLYORDER 2\n")
        f.write("!SOL_POLYORDER 0\n")
        f.write("!ELEM_TYPES Prism\n")
        f.write(f"!NB_ELEM_PER_TYPE {len(prisms)}\n")
        f.write("!NB_NODES_PER_TYPE 18\n")
        f.write("!NB_STATES_PER_TYPE 1\n")
        f.write("!LIST_ELEM\n")
        
        # Write prisms with state ID at the end
        state_id = 0
        for prism_nodes in prisms.values():
            # CFmesh uses 0-based indexing
            corrected_nodes = [node - 1 for node in prism_nodes]
            f.write(" ".join(map(str, corrected_nodes)) + f" {state_id}\n")
            state_id += 1

        # Write boundary conditions (TRSs)
        f.write("!NB_TRSs 2\n")
        
        # Inlet section
        f.write("!TRS_NAME Inlet\n")
        f.write("!NB_TRs 1\n")
        f.write(f"!NB_GEOM_ENTS {len(inlet)}\n")
        f.write("!GEOM_TYPE Face\n")
        f.write("!LIST_GEOM_ENT\n")
        for triangle_nodes in inlet.values():
            corrected_nodes = [node - 1 for node in triangle_nodes]
            f.write("6 0 " + " ".join(map(str, corrected_nodes)) + "\n")
        
        # Outlet section
        f.write("!TRS_NAME Outlet\n")
        f.write("!NB_TRs 1\n")
        f.write(f"!NB_GEOM_ENTS {len(outlet)}\n")
        f.write("!GEOM_TYPE Face\n")
        f.write("!LIST_GEOM_ENT\n")
        for triangle_nodes in outlet.values():
            corrected_nodes = [node - 1 for node in triangle_nodes]
            f.write("6 0 " + " ".join(map(str, corrected_nodes)) + "\n")

        # List of nodes
        f.write("!LIST_NODE\n")
        for _, coords in nodes.items():
            f.write("{} {} {}\n".format(coords[0], coords[1], coords[2]))
        
        # List state
        f.write("!LIST_STATE 0\n")
        f.write("!END\n")

    print(f"CFmesh file written: {filename}")


def write_msh(filename: str, 
              nodes: Dict, 
              prisms: Dict, 
              inlet: Dict, 
              outlet: Dict):
    """
    Write mesh to Gmsh MSH format (version 2.2).
    
    Parameters
    ----------
    filename : str
        Output filename
    nodes : dict
        Node dictionary
    prisms : dict
        Prism element dictionary
    inlet : dict
        Inlet boundary triangles
    outlet : dict
        Outlet boundary triangles
    """
    with open(filename, 'w') as file:
        # Write MSH file header
        file.write("$MeshFormat\n2.2 0 8\n$EndMeshFormat\n")
        
        # Write physical names (boundary and volume tags)
        file.write("$PhysicalNames\n")
        file.write("3\n")
        file.write("2 1 \"Inlet\"\n")
        file.write("2 2 \"Outlet\"\n")
        file.write("3 3 \"InnerCells\"\n")
        file.write("$EndPhysicalNames\n")
        
        # Write nodes
        file.write("$Nodes\n")
        file.write(str(len(nodes)) + "\n")
        for node_id, coords in nodes.items():
            file.write("{} {} {} {}\n".format(node_id, coords[0], coords[1], coords[2]))
        file.write("$EndNodes\n")
        
        # Write elements
        file.write("$Elements\n")
        total_elems = len(prisms) + len(inlet) + len(outlet)
        file.write(str(total_elems) + "\n")

        elem_id = 0

        # Inlet triangles (Gmsh type 9: 6-node triangle)
        for triangle_nodes in inlet.values():
            elem_id += 1
            file.write(" ".join(map(str, [elem_id, 9, 2, 1, 1] + triangle_nodes)) + "\n")
        
        # Outlet triangles
        for triangle_nodes in outlet.values():
            elem_id += 1
            file.write(" ".join(map(str, [elem_id, 9, 2, 2, 2] + triangle_nodes)) + "\n")
            
        # Prisms (Gmsh type 13: 18-node prism)
        # Note: Node ordering differs between MSH and CFmesh formats
        for prism_nodes in prisms.values():
            elem_id += 1
            # Reorder nodes for MSH format
            msh_prism_nodes = [
                prism_nodes[0], prism_nodes[1], prism_nodes[2],  # Bottom corners
                prism_nodes[3], prism_nodes[4], prism_nodes[5],  # Top corners
                prism_nodes[6], prism_nodes[8], prism_nodes[9],  # Bottom edge mids (reordered)
                prism_nodes[7], prism_nodes[10], prism_nodes[11], # Mid-height edge mids (reordered)
                prism_nodes[12], prism_nodes[14], prism_nodes[13], # Top edge mids (reordered)
                prism_nodes[15], prism_nodes[17], prism_nodes[16]  # Additional mids (reordered)
            ]
            file.write(" ".join(map(str, [elem_id, 13, 2, 3, 3] + msh_prism_nodes)) + "\n")

        file.write("$EndElements\n")

    print(f"MSH file written: {filename}")


# ============================================================================
# SECTION 4: MAIN EXECUTION
# ============================================================================

def generate_spherical_shell_mesh(inner_radius: float,
                                  outer_radius: float,
                                  refinement_level: int = None,
                                  num_points: int = None,
                                  num_layers: int = None,
                                  distribution: str = 'geometric',
                                  growth_ratio: float = 1.0,
                                  bump_ratio: float = None,
                                  manual_heights: List[float] = None,
                                  output_format: str = 'cfmesh',
                                  output_filename: str = None,
                                  sphere_method: str = 'icosphere'):
    """
    Generate a complete spherical shell mesh.
    
    Parameters
    ----------
    inner_radius : float
        Inner sphere radius
    outer_radius : float
        Outer sphere radius
    refinement_level : int, optional
        Refinement level for icosphere method (0-5)
    num_points : int, optional
        Number of points for fibonacci method (gives ~2*N-4 triangles)
    num_layers : int, optional
        Number of layers (required unless using manual heights)
    distribution : str
        Layer distribution: 'equidistant', 'geometric', 'bump', or 'manual'
    growth_ratio : float
        Growth ratio for geometric distribution
    bump_ratio : float, optional
        Ratio of boundary to middle layer thickness for bump distribution (0-1)
        Smaller values = more refinement at boundaries (default: 0.3)
    manual_heights : list of float, optional
        Manual layer heights
    output_format : str
        Output format: 'cfmesh', 'msh', or 'both'
    output_filename : str, optional
        Output filename (without extension)
    sphere_method : str
        Method for generating sphere surface: 'icosphere' or 'fibonacci'
    """
    # Validate inputs
    if inner_radius >= outer_radius:
        raise ValueError("Inner radius must be less than outer radius")
    
    # Validate sphere method and required parameters
    if sphere_method == 'icosphere':
        if refinement_level is None:
            raise ValueError("refinement_level required for icosphere method")
        num_triangles = 20 * 4**refinement_level
    elif sphere_method == 'fibonacci':
        if num_points is None:
            raise ValueError("num_points required for fibonacci method")
        if num_points < 4:
            raise ValueError("num_points must be at least 4")
        num_triangles = 2 * num_points - 4  # Approximate from Euler's formula
    else:
        raise ValueError(f"Unknown sphere_method: {sphere_method}. Use 'icosphere' or 'fibonacci'")
    
    if distribution == 'manual':
        if manual_heights is None:
            raise ValueError("Manual heights required for manual distribution")
        num_layers = len(manual_heights)
    else:
        if num_layers is None:
            raise ValueError("Number of layers required for non-manual distribution")
    
    total_height = outer_radius - inner_radius
    
    # Generate output filename if not provided
    if output_filename is None:
        if sphere_method == 'icosphere':
            output_filename = f"{num_layers}x{num_triangles}-r{inner_radius}"
        else:
            output_filename = f"{num_layers}x{num_points}pts-r{inner_radius}"

    
    print("=" * 70)
    print("SPHERICAL SHELL MESH GENERATOR")
    print("=" * 70)
    print(f"Inner radius: {inner_radius}")
    print(f"Outer radius: {outer_radius}")
    print(f"Shell thickness: {total_height}")
    print(f"Sphere method: {sphere_method}")
    if sphere_method == 'icosphere':
        print(f"Refinement level: {refinement_level} ({num_triangles} triangles)")
    else:
        print(f"Number of points: {num_points} (~{num_triangles} triangles)")
    print(f"Number of layers: {num_layers}")
    print(f"Distribution: {distribution}")
    if distribution == 'geometric':
        print(f"Growth ratio: {growth_ratio}")
    elif distribution == 'bump':
        print(f"Bump ratio: {bump_ratio if bump_ratio else 0.3} (boundary/middle layer ratio)")
    print("=" * 70)
    
    # Step 1: Generate inner sphere surface mesh
    print("\n[1/4] Generating inner sphere surface...")
    if sphere_method == 'icosphere':
        vertices, midpoint_indices = create_icosphere(inner_radius, refinement_level)
    else:
        vertices, midpoint_indices = create_fibonacci_sphere(inner_radius, num_points)
    
    # Convert to node and triangle dictionaries
    nodes = {i+1: list(v) for i, v in enumerate(vertices)}
    triangles = {}
    tri_id = 1
    for (v1, v2, v3), (m1, m2, m3) in midpoint_indices.items():
        triangles[tri_id] = [v1+1, v2+1, v3+1, m1+1, m2+1, m3+1]
        tri_id += 1
    
    print(f"Inner sphere mesh: {len(nodes)} nodes, {len(triangles)} triangles")
    
    # Step 2: Calculate layer heights
    print("\n[2/4] Calculating layer heights...")
    layer_heights = calculate_layer_heights(num_layers, total_height, 
                                            distribution, growth_ratio, manual_heights, bump_ratio)
    
    # Step 3: Extrude to create 3D mesh
    print("\n[3/4] Extruding mesh radially...")
    all_nodes, prisms, outlet_triangles = extrude_triangles(nodes, triangles, layer_heights)
    
    # Step 4: Write output files
    print("\n[4/4] Writing output files...")
    if output_format in ['cfmesh', 'both']:
        cfmesh_file = output_filename if output_filename.endswith('.CFmesh') else f"{output_filename}.CFmesh"
        write_CFmesh(cfmesh_file, all_nodes, prisms, triangles, outlet_triangles)
    
    if output_format in ['msh', 'both']:
        msh_file = output_filename if output_filename.endswith('.msh') else f"{output_filename}.msh"
        write_msh(msh_file, all_nodes, prisms, triangles, outlet_triangles)
    
    print("\n" + "=" * 70)
    print("MESH GENERATION COMPLETE")
    print("=" * 70)


def main():
    """Command-line interface for mesh generation."""
    parser = argparse.ArgumentParser(
        description='Generate spherical shell mesh with prismatic Q2 elements',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Icosphere with geometric progression (20 layers)
  python generate_spherical_shell_Q2.py -r 21.5 -R 235 -l 3 -n 20 -d geometric -k 1.2
  
  # Fibonacci sphere with 500 points (~996 triangles)
  python generate_spherical_shell_Q2.py -r 21.5 -R 235 -p 500 -n 20 -s fibonacci
  
  # Bump distribution (refined at both boundaries)
  python generate_spherical_shell_Q2.py -r 21.5 -R 235 -l 3 -n 20 -d bump -b 0.2
  
  # Equidistant layers
  python generate_spherical_shell_Q2.py -r 21.5 -R 235 -l 3 -n 30 -d equidistant
  
  # Manual layer heights
  python generate_spherical_shell_Q2.py -r 1.0 -R 2.0 -l 2 -d manual -m 0.3 0.4 0.3
  
  # Output both CFmesh and MSH formats
  python generate_spherical_shell_Q2.py -r 21.5 -R 235 -l 3 -n 20 -k 1.2 -f both

Sphere Methods:
  icosphere  : Refinement levels give 20, 80, 320, 1280, 5120 triangles (4x per level)
  fibonacci  : Arbitrary point count, ~2N-4 triangles (e.g., 500 pts → ~996 triangles)
        """
    )
    
    # Required arguments
    parser.add_argument('-r', '--inner-radius', type=float, required=True,
                        help='Inner sphere radius')
    parser.add_argument('-R', '--outer-radius', type=float, required=True,
                        help='Outer sphere radius')
    
    # Sphere surface method arguments
    parser.add_argument('-s', '--sphere-method', type=str, default='icosphere',
                        choices=['icosphere', 'fibonacci'],
                        help='Method for sphere surface mesh (default: icosphere)')
    parser.add_argument('-l', '--refinement-level', type=int,
                        help='Refinement level for icosphere (0-5). Gives 20*4^l triangles')
    parser.add_argument('-p', '--num-points', type=int,
                        help='Number of points for fibonacci method. Gives ~2N-4 triangles')
    
    # Layer distribution arguments
    parser.add_argument('-n', '--num-layers', type=int,
                        help='Number of radial layers (required for equidistant/geometric/bump)')
    parser.add_argument('-d', '--distribution', type=str, 
                        default='geometric',
                        choices=['equidistant', 'geometric', 'bump', 'manual'],
                        help='Layer height distribution method (default: geometric)')
    parser.add_argument('-k', '--growth-ratio', type=float, default=1.0,
                        help='Growth ratio for geometric distribution (default: 1.0)')
    parser.add_argument('-b', '--bump-ratio', type=float, default=None,
                        help='Bump ratio for bump distribution: boundary/middle layer ratio (0-1, default: 0.3). Smaller = more refinement at boundaries')
    parser.add_argument('-m', '--manual-heights', type=float, nargs='+',
                        help='Manual layer heights (space-separated)')
    
    # Output arguments
    parser.add_argument('-f', '--format', type=str, default='cfmesh',
                        choices=['cfmesh', 'msh', 'both'],
                        help='Output format (default: cfmesh)')
    parser.add_argument('-o', '--output', type=str,
                        help='Output filename (without extension)')
    
    args = parser.parse_args()
    
    # Validate sphere method arguments
    if args.sphere_method == 'icosphere' and args.refinement_level is None:
        parser.error("--refinement-level (-l) is required for icosphere method")
    if args.sphere_method == 'fibonacci' and args.num_points is None:
        parser.error("--num-points (-p) is required for fibonacci method")
    
    # Generate mesh
    generate_spherical_shell_mesh(
        inner_radius=args.inner_radius,
        outer_radius=args.outer_radius,
        refinement_level=args.refinement_level,
        num_points=args.num_points,
        num_layers=args.num_layers,
        distribution=args.distribution,
        growth_ratio=args.growth_ratio,
        bump_ratio=args.bump_ratio,
        manual_heights=args.manual_heights,
        output_format=args.format,
        output_filename=args.output,
        sphere_method=args.sphere_method
    )


if __name__ == '__main__':
    main()
